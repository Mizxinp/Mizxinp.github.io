<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三、处理机调度与死锁]]></title>
    <url>%2F2018%2F08%2F28%2F%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[处理机调度的层次和调度算法的目标1.处理机调度的层次 高级调度：调度对象是作业，主要用于多道批处理系统中 中级调度：即内存调度。目的是提高内存的利用率和系统的吞吐率 低级调度：调度对象是进程 作业与作业调度1.作业概念：作业不仅包含了通常的程序和数据，而且还应配有一份作业说明说，系统根据说明书来对程序的运行进行控制。 主要任务：根据作业控制块中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它创建进程，分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度 2.作业调度先来先服务调度算法：优先考虑在系统中等待时间最长的作业，不管该作业所需执行时间的长短。 短作业优先的调度算法：以作业的长短计算优先级，作业越短，其优先级越高 进程调度1.任务 保存处理机的现场信息 按某种算法选取进程 吧处理器分配给进程 2.调度机制 排队器：事先将就绪进程按一定策略排队 分派器；将处理机分配给选到的进程 上下文切换器：进行上下文切换 3.进程调度方式3.1非抢占方式一旦把处理机分配给某个进程时，就一直让它进行下去，不会因为中断请求等将去抢占正在运行进程的处理机。 3.2.抢占方式允许调度程序根据某些规则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程 遵循一定的原则： 优先权原则 短进程优先原则 时间片原则 死锁概述1.定义如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，则该组进程是死锁的 可抢占资源是不会引起死锁的，像CPU、主存等 不可抢占资源会引起死锁，像磁带机，打印机等 2.产生的条件同时具备以下四个条件 互斥条件 请求和保持条件 不可抢占条件 循环等待条件 3.处理死锁的方法 预防死锁 避免死锁 检测死锁 解除死锁 预防死锁原理：因为互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，所以主要是破坏产生死锁的后三个条件 1.破坏“请求和保持”条件保证当一个进程在请求资源时，它不能持有不可抢占资源。通过两种协议实现这种保证 规定所有进程在开始运行前，必须一次性的申请其在整个运行过程中所需的全部资源 允许一个进程只获得运行初期所需的资源后，便开始运行，然后在逐步的边释放边请求资源 2.破坏“不可抢占”条件规定当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请 3.破坏“循环等待”条件对系统所有资源类型进行线性排序，进程只能按编号顺序来请求资源。 避免死锁在程序运行时避免发生死锁，确保系统始终出于安全状态 1.安全状态指系统能某种进程推进顺序为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。 2.利用银行家算法避免死锁刚开始是为银行系统设计的，确保银行在发放现金贷款是，不会发生不能满足所有客户需要的情况 2.1.银行家算法中的数据结构 可利用资源向量Available。一个含有m个元素的数组 最大需求矩阵Max。一个n x m的矩阵。定义n个进程中的每一个进程对m类资源的最大需求 分配矩阵Allocation。一个n x m的矩阵。定义系统中每一类资源当前已分配给每一道进程的资源数 需求矩阵Need。一个n x m的矩阵。表示每一个进程尚需的各类资源数 2.2.银行家算法步骤： 1.如果Request &lt;= Need,转向步骤二，否则出错 2.如果Available &lt;= Allocation，转向步骤三，否则等待 3.系统试探把资源分配给进程，并修改下面数值 Available = Available - Request Allocation = Allocation + Request Need = Need - Request 4.系统执行安全性算法，处于安全状态则分配 2.3.安全性算法 1.设置两向量： （1）工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，刚开始Work = Available。 （2）Finish：表示系统是否有足够的资源分配给进程，刚开始Finish = false 2.从进程集合找到一个满足下述条件的进程，若找到，转到步骤3，否则转到步骤4 Finish = false Need = Work 3.当进程获得资源后。可顺利执行，直至完成，并释放出分配给它的资源，故执行 Work = Work + Allocation Finish = true go to step2 4.如果所有进程的Finish = true都满足，则表示系统处于安全状态。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、jQuery中的DOM操作]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%89%E3%80%81jQuery%E4%B8%AD%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.查找节点1.1.查找元素节点和属性节点1234// 获取ul元素里第2个li节点var $li = $('ul li:eq(1)');// 查找属性用arrt()方法var p_txt = $('p').arrt('title'); 2.创建节点2.1创建元素，文本，属性节点利用$(html)实现12// 创建一个li标签，包括元素节点'li'，文本节点'新闻'和属性节点'title'var $li = $("&lt;li title='新闻'&gt;新闻&lt;/li&gt;") 3.插入节点3.1.append()方法向每个匹配的元素内部追加内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').append('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt; 3.2.appdendTo()方法将所有匹配的元素追加到指定的元素中，与append()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').appendTo('p')// 结果&lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt; 3.3.prepend()方法向每个匹配的元素内部追前置内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').prepend('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt; 3.4.prependTo()方法将所有匹配的元素前置到指定的元素中，与prepend()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').prependTo('p')// 结果&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt; 3.5.after()方法在每个匹配的元素之后插入内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').after('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; 3.6.insertAfter()方法将所有匹配的元素插入到指定的元素后面，与after()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').insertAfter('p')// 结果&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; 3.7.before()方法在每个匹配的元素之前插入内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').before('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;b&gt;你好&lt;/b&gt;&lt;p&gt;我想说：&lt;/p&gt; 3.8.insertBefore()方法将所有匹配的元素插入到指定的元素前面，与after()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').insertBefore('p')// 结果&lt;b&gt;你好&lt;/b&gt;&lt;p&gt;我想说：&lt;/p&gt; 4.删除节点4.1.remove()方法删除该节点所包含的所有后代节点 12// 删除ul下的第二个li元素$('ul li:eq(1)').remove(); 4.2.empty()方法清空该节点所包含的所有后代节点 12// 清空ul下的第二个li元素里的内容，但还剩下li标签默认的符号'·'$('ul li:eq(1)').remove(); 5.复制节点5.1clone()方法在clone()方法中可以传递一个参数true，表示复制元素的同时也复制了元素中的绑定事件 6.替换节点6.1.replaceWith()方法：将匹配到的元素替换成指定的html或dom元素 1$('p').replaceWith('&lt;span&gt;哈哈&lt;/span&gt;') 6.2.replaceAll()方法：与replaceWith()方法作用一致，只是颠倒了replaceWith()操作 1$('&lt;span&gt;哈哈&lt;/span&gt;').replaceAll('p') 7.包裹节点7.1wrap()方法将所有的元素进行一个一个单独包裹 7.3wrapAll()方法将所有匹配到的元素用一个元素包裹 7.3wrapInner()方法将每一个匹配的元素的子内容（包括文本节点）包裹起来 8.属性操作8.1.获取和设置属性attr()方法传一个参数即获取，两个参数即设置 8.2.删除属性用removeAttr()方法 9.样式操作9.1.获取和设置样式用attr(‘class’,’xxx’)实现类名的设置 9.2.追加样式使用addClass()方法操作 9.3.移除样式使用removeClass()方法操作 9.4.切换样式使用toggle()方法操作 9.5.判断是否含有某样式使用hasClass()方法操作 10.设置和获取HTML，文本和值使用html()方法,text()方法和val()方法分别获取HTML，文本和文本框等的值，不传参数是获取，传是设置 11.遍历节点11.1.children()方法取得匹配元素的子元素集合，只考虑子元素不考虑后代元素 11.2.next()方法取得匹配元素后面紧邻的同辈元素 11.3.prev()方法取得匹配元素后面紧邻的同辈元素 11.4.siblings()方法取得匹配元素前后所有的同辈元素 11.5.closest()方法取得最近的匹配元素，先检查当前元素是否匹配，若匹配直接返回元素本身.不匹配向上查找父元素 12.CSS-DOM操作12.1.css()方法12// 可设置多个样式$('p').css(&#123;'fontSize':'30px','backgroundColor':'#666'&#125;) 12.2.offset()方法获取元素在当前视窗的相对偏移，返回top和left两个属性 12// 获取p元素的offset()var offset = $('p').offset() 12.3.position()方法获取相对于最近的一个position样式属性设置为relative或absolute的祖父节点的相对偏移，也返回top和left两个属性 12// 获取p元素的position()var position = $('p').position() 12.4.scrollTop()方法和scrollLeft()方法。分别获取元素的滚动条距顶端的距离和距左侧的距离。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之引用类型]]></title>
    <url>%2F2018%2F08%2F24%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.Object类型1.1创建Object实例的两种方法12345678910//第一种：使用Object构造函数的方法var person = new Object();person.name = '张三';person.age = 18;// 第二种：使用对象字面量的形式var person = &#123; person.name = '张三'; person.age = 18;&#125; 1.2访问属性的两种方法12345//第一种：点表示法console.log(person.name);// 第二种：方括号法console.log(person['name']); 属性名中是可以包含非字母非数字的，这时候就可以使用方括号来访问它们。 注意：除非必要使用变量来访问属性，否则我们建议使用点表示法 2.Array类型创建数组也有两种方式：Array构造函数和数组字面量方式 注意： 12var value = [1,2]; //会创建2或3项（ie8以下）var value = [,,,,,]; // 会创建5或6项（ie8以下） 如果将数组的length属性设置大于数组项数的值，则新增的每一次都会取的undefined的值 当把一个值放在超出当前数组大小的位置时，数组就会重新计算其长度值 2.1检测数组2.1.1.instanceof操作符：用法：value instanceof Array存在的问题：假定只有一个全局执行环境才有用 2.1.2.Array.isArray()方法用法：Array.isArray(value) 2.2转换方法2.2.1.toString()方法返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串 2.2.2.valueof()方法返回数组 2.2.3.toLocalString()方法：join()方法:使用不同的分隔符来构建字符串，只接受一个参数， 12var color = ["red","green"];color.join(','); //"red,green" 2.3.栈方法2.3.1.push()添加到末尾，返回修改后的长度 2.3.2.pop()移除最后一项，返回移除的项 2.4.队列方法2.4.1.unshift()数组前端添加任意个项并返回新数组的长度（ie7以下返回undefined） 2.4.2.shift()移除第一项并返回该项 2.5.重排列方法2.5.1.reverse()反转数组 2.5.2.sort()按升序排列 注意： sort()方法会调用每个数组项的toString()转型方法，比较的是字符串 12var value = [0,1,5,10,15];value.sort(); //[0,1,10,15,5] 字符串中"10"位于"5"前 因此若想正确排序，sort()方法可以接收一个比较函数作为参数 123456789101112function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;var value = [0,1,5,10,15];value.sort(compare); //[0,1,5,10,15] 字符串中"10"位于"5"前 2.6.操作方法concat()方法:先创建当前数组一个副本，有参数就添加到副本末尾，返回新构建的数组。不会影响原始数组 slice()方法：接收一或两个参数，不影响原始数组： 一个参数：返回从该参数指定位置开始到当前数组末尾的所有项。 两个参数：返回起始和结束位置之间的项但不包括结束位置的项。 如果参数中有负数，则用数组长度加上该数来确定响应的位置，如对于一个长度为5的数组，调用slice(-2,-1)与调用slice(3,4)是一样的。如果结束位置小于起始位置，则返回空数组 splice()方法:有删除，插入，替换的用途。 删除：两个参数，splice(要删除的第一项的位置,要删除的项数) 插入：三个参数：splice(起始位置，0（要删除的项数），要插入的项数) 替换；三个参数：splice(起始位置，要删除的项数，要插入的项数)，插入的项数与删除的项数不必相等 该方法始终都会返回一数组，包含从原始数组中删除的项（没有删除则返回一个空数组） 2.7.位置方法indexof()方法和lastIndex()方法:这两个方法都接收两个参数：要查找的项和（可选）表示起点位置的索引。其中indexof方法从数组开头开始往后查找，lastIndex方法则从数组末尾向前查找 都返回要查找的项在数组中的位置，没找到返回-1，使用全等操作符 ie9以下不支持 2.8.迭代方法迭代方法都接收两个参数：在每一项上运行的函数和（可选）运行该函数的作用域对象———影响this的值。传入的函数接收三个参数：数组项的值，该项在数组中的位置和数组对象本身 2.8.1.every()方法:如果该函数对 每一项 都返回true，则返回true 2.8.2.filter()方法:返回一个数组，包含该函数会返回true的项。可应用与查询符合某些条件的所有数组项 12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item,index,array)&#123; return (item &gt; 2);&#125;);console.log(filterResult); //[3,4,5,4,3] 2.8.3.forEach()方法:没有返回值 2.8.4.map()方法:返回每次函数调用的结果组成的数组，适用创建包含的项与另一个数组一一对应的数组 2.8.5.some()方法:对数组中的 某一项 返回true，则返回true 2.9.归并方法2.9.1reduce()方法和reduceRight()方法reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()方法则从数组的最后一项开始，向前遍历到第一项。 都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传入的函数接收四个参数：前一个值，当前值，项的索引和数组对象这个函数返回的任何值都会作为第一个参数自动传给下一项。 123456var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; //第一次prev是1，cur是2.第二次prev是3，cur是3 return prev + cur;&#125;);console.log(sum) //15 3.Date类型创建一个日期对象1var now = new Date() 两个方法：Date.parse()和Date.UTC() 3.1.Date.parse()方法:接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，若参数不能表示日期，则返回NaN 3.2.Date.UTC()方法：返回表示日期的毫秒数，参数分别是年份（必需），基于0的月份（必需），月中的哪一天（1到31），小时数（0到23），分钟，秒以及毫秒数 3.3.Date.now()方法:返回调用这个方法时的日期和时间的毫秒数，等同于 +new Date() 。 3.4.日期格式化方法 toDateString()：以特定于实现的格式显示星期几，月，日和年 toTimeString()：以特定于实现的格式显示时，分，秒和时区 toLocaleDateString()：以特定于实现的格式显示星期几，月，日和年 toLocaleTimeString()：以特定于实现的格式显示时，分，秒 toUTCString()：以特定于实现的格式完整的UTC日期 3.5.日期/时间组件方法 getTime(): setTime() getFullYear() setFullYear()…… 4.Function类型每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法，由于函数是对象，因此函数名实际上也是函数对象的指针 4.1.没有重载javascript中没有函数重载的概念，所以若声明了两个同名函数，则后面的函数会覆盖前面的函数 4.2.函数声明与函数表达式解析器在向执行环境中加载数据时，会率先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式，必须等到解析器执行到它所在的代码行，才会被解释执行。在代码执行之前，JavaScript引擎会将函数声明放到源代码树的顶部 123456789console.log(sum(10,10)); //20function sum(num1,num2)&#123; return num1 + num2&#125;console.log(sum(10,10)); //报错var sum = function(num1,num2)&#123; return num1 + num2&#125; 4.3.作为值的函数函数本身就是变量，所以不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数的结果返回。 1234567891011121314151617function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument);&#125;function add10(num)&#123; return num + 10;&#125;var result = callSomeFunction(add10,10);console.log(result); //20function getGreenting(name)&#123; return "hello," + name;&#125;var result2 = callSomeFunction(getGreenting,"jack");console.log(result2); // hello,jack 4.4.函数内部属性函数内部有两个特殊的对象：arguments和this。 arguments：保存函数参数，有一个callee属性，指向拥有这个arguments对象的函数。 函数对象的属性：caller：保存着调用当前函数的函数的引。用，如果在全局作用域中调用当前函数，值为null 1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); //function outer()&#123;inner()&#125;;&#125;outer(); 会打印出outer()函数的源代码，因为outer调用了inner(),所以inner.caller就指向了outer()。 注意：在严格模式下运行，访问arguments.callee会导致错误，而arguments.caller属性无论在严格还是非严格模式都是undefined，定义这个属性主要是为了分清arguments.caller和函数的caller属性 在严格模式下不能为函数的caller属性复制，否则会导致错误 4.5.函数属性和方法属性：length和prototype每个函数都包含两个非继承而来的方法：call()和apply() 这些的用法在另外的文章有专门记录 5.基本包装类型3个特殊的引用类型：Boolean，Number和String。 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象： 12var s1 = "some text";var s2 = s1.substring(2); 正常基本数据类型不应该有方法的，但是它在后台完成一些操作，相当于 123var s1 = new String("some text"); //创建String类型的一个实例var s2 = s1.substring(2); //在实例上调用指定的方法s1 = null; //销毁这个实例 5.1.引用类型和基本包装类型的主要区别主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流结束离开作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，所以不能在运行时为基本类型的值添加属性和方法。 对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true 5.2.Boolean类型重写了valueOf()方法，返回基本类型值true或false，重写toString()和toLocalString()方法，返回字符串”true”和”false” 引用类型的布尔值与基本类型的区别： typeof操作符：基本类型返回”boolean”，引用类型返回”object” instanceof操作符：对Boolean对象返回true，对基本类型返回false 注意： 123var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;console.log(result); //true 布尔表达式的所有对象都会被转为true，所以falseObject为true 5.3.Number类型Number对象是Number类型的实例，基本类型不是 重写了valueOf()方法，返回对象表示的基本类型数值，重写toString()和toLocalString()方法，返回字符串类型数值 5.3.1几个方法： toFixed()：按指定的小数位返回数值的字符串 toExponential()：返回指数表示法 toPrecision()：根据具体情况选择最合适的方法，toFixed()或toExponential() 5.4.String类型5.4.1.字符方法5.4.2.charAt()方法,charCodeAt()方法访问特定字符串中特定的方法，接收一个参数，基于0位置。charAt()方法以单字符字符串返回给定位置的那个字符。charCodeAt()方法返回字符编码 123456var string = "hello world";console.log(string.charAt(1)) //"e"console.log(string.charCodeAt(1)) //"101"//方括号表示法:ie8以下会返回undefinedconsole.log(string[1] //"e" 5.4.3.字符串方法5.4.4.concat()方法字符串拼接，不影响原字符串 5.4.5.slice()方法，substr()方法和substring()方法返回被操作字符串的子字符串，接收一或两个参数，第一个参数为开始位置。第二个参数：slice()方法和substring()方法指定 最后一个字符后面的位置，substr()方法指定返回字符的个数，不影响原字符串 1234567var string = "hello world";console.log(string.slice(3)) //"lo world"console.log(string.substring(3)) //"lo world"console.log(string.substr(3)) //"lo world"console.log(string.slice(3,7)) //"lo w"console.log(string.substring(3,7)) //"lo w"console.log(string.substr(3,7)) //"lo worl" 对于负数：slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，负的第二个参数转换为0。substring()方法会将所有的负数转换为0。 1234567var string = "hello world";console.log(string.slice(-3)) //"rld"console.log(string.substring(-3)) //"hello world"console.log(string.substr(-3)) //"rld"console.log(string.slice(3,-4)) //"lo w"console.log(string.substring(3,-4)) //"hel" 相当于调用substring(0,3)console.log(string.substr(3,-4)) //"" （空字符串） 5.5.字符串位置方法5.5.1.indexOf()方法与lastIndexOf()方法使用方法与Array类型的一致 5.5.2.trim()方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，不影响原字符串，ie9以上支持 5.6.大小写转换方法 toLowerCase()：转小写 toUpperCase()：转大写 toLocalLowerCase()：特定地区小写 toLocalUpperCase()：特定地区大写 5.7.模式匹配方法5.7.1.math()方法接收一个参数，要么是正则表达式，要么是一个RegExp 5.7.2.search()方法接收一个参数：字符串或RegExp对象指定的一个正则表达式。返回字符串中第一个匹配项的索引 5.7.3.replace()方法接收两个参数：第一个参数可以是一个字符或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替代第一个子字符串。 123var text = "cat,bat,sat";var result = text.replace("at","ond");console.log(result); //"cond,bat,sat" 5.7.4.split()方法基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。（用的比较多） 123var colors = "red,blue,green";var colors1 = colors.split(",");console.log(colors1); //["red","blue","green"] 6.单体内置对象6.1.Global对象所有在全局作用域中定义的属性和函数，都是Global对象。 6.1.1.URI编码方法encodeURI()方法：除了空格之外的其他字符都原封不动，只有空格被替换成了%20。encodeURIcomponent()：替换所有非字母数字字符 6.1.2.eval()方法像一个完整的ECMAScript解析器，接收一个参数，即要执行的JavaScript字符串。 123eval("alert('hi')");//等价于alert("hi"); 在eval()中创建的任何变量或函数都不会被提升 严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误。 6.1.3.Global对象的属性ECMAScript5明确禁止给undefined、NaN和Infinity赋值。 6.2.Math对象6.2.1.min()和max()方法。确定最大最小值。 要找到数组中的最大或最小值，可以使用apply()方法 123var values = [1,2,3,4,5,6,7];var max = Math.max.apply(Math,values);console.log(max); //7 6.2.2.舍入方法 Math.ceil()：向上舍入，将数值向上舍入为最接近的值 Math.floor()：向下舍入，将数值向下舍入为最接近的值 Math.ceil()：标准舍入，即四舍五入 6.2.3.random()方法Math.random()方法返回大于等于0小于0的一个随机数。 可用于随机显示一些名人名言和新闻事件： 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 6.2.4.其他方法像Math.abs(num)、Math.sqrt(num)等等]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、jQuery选择器]]></title>
    <url>%2F2018%2F08%2F19%2F%E4%BA%8C%E3%80%81jQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.基本选择器 选择器 描述 返回 示例 #id 根据给定的的id匹配一个元素 单个元素 $(“#btn”) .class 根据给定的class匹配元素 集合元素 $(“.class”) element 根据给定的元素匹配元素 集合元素 $(“div”) * 匹配所有元素 集合元素 $(“*”) selector1，selector2… 将每个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.demo”) 2.层次选择器 选择器 描述 返回 示例 $(“ancestor descendant”) 选取ancestor元素里的所有decendant（后代）元素 集合元素 $(“parent&gt;child”) 选取parent元素下的child（子）元素 集合元素 $(“prev+next”) 选取紧接在prev元素后的next元素 集合元素 $(“prev~siblings”) 选取prev元素之后的所有sibling（兄弟）元素 集合元素 3.过滤选择器3.1.基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(“div:first”)选取所有div元素中第一个div元素 :last 选取最后一个元素 单个元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(“input:not(.myClass)”)选取class不是myClass的input元素 :even 选取索引是偶数的所有元素，索引从0开始 集合元素 :odd 选取索引是奇数的所有元素，索引从0开始 集合元素 :eq(index) 选取索引等于index的元素（index从0开始） 单个元素 :gt(index) 选取索引大于index的元素（index从0开始） 集合元素 $(“input:gt(1)”)选取索引大于1的input元素（大于1，不包括1） :lt(index) 选取索引小于index的元素（index从0开始） 集合元素 :header 选取所有的标题元素，如h1，h2等 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 3.2.内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(“div:contains(‘我’)”)选取含有文本“我”的div元素 :empty 选取不包含子元素或者文本为空的元素 集合元素 :has(selector) 选组含有选择器所匹配的元素的元素 集合元素 $(“div:has(p)”)选取含有p元素的div元素 :parent 选取含有子元素或者文本的元素 集合元素 3.3.可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 3.4.属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(“div[title=test]”)选取属性title为“test”的div元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 [attribute^=value] 选取属性的值以value的开头的元素 集合元素 [attribute$=value] 选取属性的值以value的结尾的元素 集合元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 [selector1][selector2] 用属性选择器合并成一个符复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(“div[id][title$=’test’]”)选取拥有属性id，并且属性title以“test”结束的div元素 3.5.子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个父元素的第一个子元素 集合元素 $(“ul li:first-child”)选取每个ul中第1个li元素 :last-child 选取每个父元素的最后一个元素 集合元素 :only-child 如果某个元素是它的父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(“ul li:only-child”)在ul中选取是唯一子元素的li元素 3.6.表单对象属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(“#form1 :enabled”)选取id为“form1”的表单内所有可用元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框，复选框） 集合元素 :selected 选取所有被选中的选项元素（下拉列表） 集合元素 4.表单选择器 选择器 描述 返回 示例 :input 选取所有input,textare,select,button元素 集合元素 :text 选取所有的单行文本框 集合元素 :password 选取所有的单行密码框 集合元素 :radio 选取所有的单选框 集合元素 :checkbox 选取所有的复选框 集合元素 :submit 选取所有的提交按钮 集合元素 :image 选取所有的图像按钮 集合元素 :reset 选取所有的重置按钮 集合元素 :button 选取所有的按钮 集合元素 :file 选取所有的上传域 集合元素 :hidden 选取所有不可见元素 集合元素]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、进程的描述与控制]]></title>
    <url>%2F2018%2F08%2F18%2F%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程的描述定义进程：由程序段，相关的数据段和PCB三部分构成 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上的运行的结果，它是系统进行资源分配和调度的一个独立单位 特征 动态性 并发性 独立性 异步性 进程的三种基本状态就绪状态：进程已处于准备好运行的状态，即已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行执行状态：进程已获得CPU，其程序正在执行的状态阻塞状态：正在执行的进程由于发生某事件（I/O请求，申请缓冲区失败等)暂时无法继续执行时的状态 三种状态的转换进程控制块PCB用于描述进程的当前情况以及管理进程运行的全部信息，使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位 具体作用； 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其它进程的同步与通信 进程控制操作系统内核：通常将一些与硬件紧密相关的模块（如中断处理程序等），各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理，进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层面中，将它们常驻内存，即称为OS内核 OS内核两大功能：支撑功能 中断处理 时钟处理 原语操作：一个操作中要么全做，要么全部不做 资源管理功能 进程管理 存储器管理 设备管理 进程同步进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源。临界资源：如打印机，磁带机等临界区：人们把在每个进程中访问临界资源的那段代码称为临界区 同步机制应遵循的规则 空闲让进 忙则等待 有限等待 让权等待 进程通信进程通信的类型 共享存储器系统 管道通信系统 消息传递系统 客户机-服务器系统 消息传递通信的实现方式 直接消息传递系统 信箱通信 线程（Threads）的基本概念线程的引入引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性 程序的并发执行需要经过创建进程，撤销进程和进程切换。在此过程系统付出里较大的时空开销 线程作为调度和分派的基本单位，能使多个程序更好的并发执行，同时又尽量减少系统的开销 线程与进程的比较调度的基本单位传统OS中，进程每次调度时进行的上下文切换，开销较大。引入线程之后，就把线程作为调度和分派的基本单位，是独立运行的基本单位，切换代价远低于进程。 并发性一个进程中的多个线程可以并发执行，使得OS具有更好的并发性，从而能更加有效的提高系统资源的利用率和系统的吞吐率 拥有资源进程可以拥有资源，并作为系统中拥有资源的一个基本单位。线程本身并不拥有系统资源，而是仅有一点能保证独立运行的资源。 独立性在同一个进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 系统开销创建或撤销进程的开销明显大于线程创建或撤销是所付出的开销 支持多处理机系统传统的进程，即单线程进程，只能运行在一个处理机上，而多线程进程，可以将一个进程中的多个线程分配到多个处理机上]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、操作系统引论]]></title>
    <url>%2F2018%2F08%2F14%2F%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[操作系统的基本特性1.并发并行性是指两个或多个事件同一时刻发生。 并发性是指两个或多个事件在同一时间间隔内发生。 操作系统通过引入进程和和线程，使程序能够并发执行。 2.共享资源共享也称资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。 有两种共享方式 互斥共享：临界资源，如打印机，磁带机等。规定一段时间内，只允许一个进程访问该资源。 同时访问：允许一段时间内由多个进程“同时”对它们进行访问。 3.虚拟把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。 主要有两种虚拟技术 时分复用技术：广泛用于实现虚拟处理机、虚拟设备等。利用率高的原因：利用某设备为一用户服务的空闲时间，又转去为其他用户服务 ，使设备得到充分利用。 空分复用技术：利用存储器的空闲时间分区域存放和运行其他的多道程序，以此来提高内存利用率。 4.异步每个进程的速度，时间等等是不可预知的。即进程是以人们不可预知的速度推进的，此即进程的异步性。 操作系统的主要功能1.处理机管理功能进程控制、进程同步、进程通信、调度。 2.存储器管理功能内存分配、内存保护、地址映射、内存扩充 3.设备管理功能缓冲管理、设备分配、设备处理 4.文件管理功能文件存储空间的管理、目录管理、文件的读/写管理和保护 微内核OS结构什么是微内核 足够小的内核 基于客户/服务器模式 应用“机制与策略分离”原理 采用面向对象技术 基本功能 进程（线程）管理 低级存储器管理 中断和陷入处理 优缺点优点： 提高系统的可扩展性 增强了系统的可靠性 可移植性强 提供了对分布式系统的支持 融入了面向对象技术 缺点 操作系统的运行效率降低（需要多次上下文的切换）]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域，了解一下]]></title>
    <url>%2F2018%2F08%2F09%2F%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[为什么要跨域同源策略同源策略是浏览器的一种安全策略，是为了保证用户信息的安全，防止恶意的网站窃取数据。所谓同源是指域名，协议，端口完全相同。 同源或者不同源说的是两个地址之间的关系，不同源之间请求我们称之为跨域请求。 如果非同源，有三种行为会受到限制： Cookie、LocalStorage和IndexDB无法读取 DOM 无法获得。 AJAX 请求不能发送。 这里主要讲AJAX如何在不同源之间发送请求。 解决跨域JSONP原理：在客户端借助script标签请求服务端的一个动态网页服务端的这个动态网页返回一段带有函数调用的JavaScript全局函数调用的脚本，将原本需要返回给客户端的数据传递进去 封装一个jsonp：123456789101112131415161718192021222324252627function jsonp(url, data, callback) &#123; //保证回调不会重名 var callbackName = 'jsonp_' + Date.now() + Math.random().toString().substr(2.7); //处理以对象形式传过来的参数 if (typeof data === 'object') &#123; var funArr = []; for (var key in data) &#123; var value = data[key]; funArr.push(key + '=' + value); &#125; data = funArr.join('&amp;'); &#125; //主要 var script = document.createElement('script'); script.src = url + '?' + data + 'callback=' + callbackName; document.body.appendChild(script); window[callbackName] = function (data) &#123; callback(data); //结束后删除标签 delete window[callbackName]; document.body.removeChild(script); &#125;&#125; 存在的问题： JSONP需要服务端配合，服务端按照客户端的要求返回一段JavaScript调用客户端的函数 只能发送GET请求 如果在jQuery中使用JSONP，就是将dataType设置为jsonp]]></content>
  </entry>
  <entry>
    <title><![CDATA[一、认识jQuery]]></title>
    <url>%2F2018%2F08%2F08%2F%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86jQuery%2F</url>
    <content type="text"><![CDATA[1.window.onload与$(document).ready()的对比 window.onload $(document).ready() 执行时机 必须等待网页中所有的内容加载完毕后（包括图片）才能执行 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完 编写个数 不能同时编写多个，编写多个只会执行最后一个 能同时编写多个，每个都会执行 简化写法 无 $(document).ready(function(){});可简写为$(function(){}) 2.jQuery对象在jQuery对象中无法使用DOM对象的任何方法，同样DOM对象也不能使用jQuery里的方法 3.jQuery对象和DOM对象的相互转换3.1.jQuery对象转成DOM对象(1) jQuery对象是一个数组对象，可以通过[index]的方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn[0]; //DOM对象 (2) 另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn.get(0); //DOM对象 3.2DOM对象转成jQuery对象12var btn = document.getElementById('btn'); //DOM对象var $btn = $(btn); //jQuery对象 4.解决jQuery和其他库的冲突4.1jQuery库在其他库之后导入在其他库和jQuery库都被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权移交给其他js库 1jQuery.noConflict(); //将变量$的控制权移交给其他js库 还可以自定义一个快捷方式 1234var $j = jQuery.noConflict(); //自定义一个快捷方式$j(function()&#123; //...&#125;) 此外还有以下两种解决方法 1234567一：jQuery.noConflict(); //将变量$的控制权移交给其他js库jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $('#btn').on('click',function()&#123; //... &#125;)&#125;) 1234567二：jQuery.noConflict(); //将变量$的控制权移交给其他js库(function($)&#123; //定义匿名函数并设置形参为$ $('#btn').on('click',function()&#123; //... &#125;)&#125;)(jQuery) //执行匿名函数且传递实参jQuery 4.2.jQuery库在其他库之前导入如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作。同时，可以使用$()方法作为其他库的快捷方式。无需调用jQuery.noConflict()函数。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise初体验]]></title>
    <url>%2F2018%2F06%2F13%2FPromise%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 想了解更多有关回调的，可以去看这篇文章Callback Hell ​ 想了解更多有关Promise的使用，推荐去阮一峰老师的ES6教程阮一峰Promise ​ 因最近在学nodejs，所以文章结合node进行说明 回调函数解决异步编程先简单了解一下回调函数解决异步操作所引起的回调地狱问题。 我们知道异步编程无法保证代码的顺序性，如 1234567891011121314151617181920var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa)&#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) &#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc)&#125;) 在这里我们不能保证按顺序输出aaa，bbb，ccc。 我们可以使用传统的回调函数嵌套的方法 来解决这样的问题： 12345678910111213141516171819var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc) &#125;) &#125;) 很显然，当嵌套过多时，既会产生人们常说的回调地狱问题。所以就有了Promise Promise是什么Promise是ES6的语法，是异步编程的一种解决方案，传统的解决异步编程方法是使用回调函数来解决，但如果需要多个回调就会有回调地狱的问题，而用Promise则会更加合理 简单来说，Promise是一个容器，里面保存着异步操作的结果,它有三种状态：pending（进行中），resolved（已成功），rejected（以失败），一旦状态改变，就不会再变回来，即从pending变为resolved和从pending变为rejected两种可能，当这两种可能已经发生，状态就不会再变了。以下的内容均结合node的异步操作来说明 简单使用Promise是一个构造函数，首先要创造一个Promise实例。 12345678910111213var promiseOne = new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; //容器中的任务失败了，把容器中的pending状态变为rejected reject(err) //调用reject就相当于调用了then方法的第二个参数函数 &#125; else &#123; //容器中的任务成功了， 把容器中的pending状态变为resolved resolve(data) //也就是说这里调用的resolve方法实际就是then方法传递的那个function &#125; &#125;)&#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 1234567promiseOne.then(function (data) &#123; //成功 console.log(data)&#125;, function (err) &#123; //失败 console.log(err)&#125;) then方法接收两个回调函数，第一个回调函数即调用上文中的resolve（data），第二个回调函数可选，即调用上文中的rejecte（err） 简单封装Promise版本的readFile方法1234567891011121314151617181920212223242526var fs = require('fs')function promiseReadFile(filePath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;promiseReadFile(filePath) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) &#125;)]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>-ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose简单操作]]></title>
    <url>%2F2018%2F06%2F10%2FMongoose%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装1npm install mongoose 快速上手1.引入mongoose模块1var mongoose = require('mongoose'); 2.定义一个Schema：一种以文件形式存储的数据库模型骨架1var Schema = mongoose.Schema 3.连接数据库,指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来(myserver是自己创建的)1mongoose.connect('mongodb://localhost/myserver') 4.设计文档结构，官方文档的123456789101112var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 这里我用这样的来做简单例子12345678910111213var userSchema = new Schema(&#123; username:&#123; type: String, require: true &#125;, password:&#123; type: String, require: true &#125;, email:&#123; type:String &#125;&#125;) 5.将Shcema发布为model mongoose.model 方法就是用来将Shcema发布为 model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称例如这里的 User 最终会变为 users 集合名称 第二个参数：架构 Schema 返回值：模型构造函数1var User = mongoose.model('User',userSchema) 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行增删改查了 增加数据1234567891011121314var admin = new User(&#123; username:'张三', password:'12345', email:'email@email.com'&#125;)admin.save(function(err,ret)&#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功'); console.log(ret) &#125;&#125;) 查询数据查询所有123456789User.find(function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 按条件查询所有1234567891011User.find(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 查询一个1234567891011User.findOne(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 删除数据按条件删除所有1234567891011User.remove(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功'); console.log(ret) &#125;&#125;) 按条件删除一个:与上面相似1Model.findOneAndRemove(condition,[option],[callback]) 根据id删除一个1Model.findByIdAndRemove(id,[option],[callback]) 更新数据根据id更新一个1234567891011User.findByIdAndUpdate('xxxxxx',&#123; username:'李四'&#125;,function(err,ret)&#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功'); console.log(ret) &#125;&#125;) 根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个1Model.findOneAndUpdate(conditions,update,[options],[callback])]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
