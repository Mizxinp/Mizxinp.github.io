<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[认识jQuery]]></title>
    <url>%2F2018%2F08%2F08%2F%E8%AE%A4%E8%AF%86jQuery%2F</url>
    <content type="text"><![CDATA[1.window.onload与$(document).ready()的对比 window.onload $(document).ready() 执行时机 必须等待网页中所有的内容加载完毕后（包括图片）才能执行 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完 编写个数 不能同时编写多个，编写多个只会执行最后一个 能同时编写多个，每个都会执行 简化写法 无 $(document).ready(function(){});可简写为$(function(){}) 2.jQuery对象在jQuery对象中无法使用DOM对象的任何方法，同样DOM对象也不能使用jQuery里的方法 3.jQuery对象和DOM对象的相互转换3.1.jQuery对象转成DOM对象(1) jQuery对象是一个数组对象，可以通过[index]的方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn[0]; //DOM对象 (2) 另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn.get(0); //DOM对象 3.2DOM对象转成jQuery对象12var btn = document.getElementById('btn'); //DOM对象var $btn = $(btn); //jQuery对象 4.解决jQuery和其他库的冲突4.1jQuery库在其他库之后导入在其他库和jQuery库都被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权移交给其他js库 1jQuery.noConflict(); //将变量$的控制权移交给其他js库 还可以自定义一个快捷方式 1234var $j = jQuery.noConflict(); //自定义一个快捷方式$j(function()&#123; //...&#125;) 此外还有以下两种解决方法 1234567一：jQuery.noConflict(); //将变量$的控制权移交给其他js库jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $('#btn').on('click',function()&#123; //... &#125;)&#125;) 1234567二：jQuery.noConflict(); //将变量$的控制权移交给其他js库(function($)&#123; //定义匿名函数并设置形参为$ $('#btn').on('click',function()&#123; //... &#125;)&#125;)(jQuery) //执行匿名函数且传递实参jQuery 4.2.jQuery库在其他库之前导入如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作。同时，可以使用$()方法作为其他库的快捷方式。无需调用jQuery.noConflict()函数。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise初体验]]></title>
    <url>%2F2018%2F06%2F13%2FPromise%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 想了解更多有关回调的，可以去看这篇文章Callback Hell ​ 想了解更多有关Promise的使用，推荐去阮一峰老师的ES6教程阮一峰Promise ​ 因最近在学nodejs，所以文章结合node进行说明 回调函数解决异步编程先简单了解一下回调函数解决异步操作所引起的回调地狱问题。 我们知道异步编程无法保证代码的顺序性，如 1234567891011121314151617181920var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa)&#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) &#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc)&#125;) 在这里我们不能保证按顺序输出aaa，bbb，ccc。 我们可以使用传统的回调函数嵌套的方法 来解决这样的问题： 12345678910111213141516171819var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc) &#125;) &#125;) 很显然，当嵌套过多时，既会产生人们常说的回调地狱问题。所以就有了Promise Promise是什么Promise是ES6的语法，是异步编程的一种解决方案，传统的解决异步编程方法是使用回调函数来解决，但如果需要多个回调就会有回调地狱的问题，而用Promise则会更加合理 简单来说，Promise是一个容器，里面保存着异步操作的结果,它有三种状态：pending（进行中），resolved（已成功），rejected（以失败），一旦状态改变，就不会再变回来，即从pending变为resolved和从pending变为rejected两种可能，当这两种可能已经发生，状态就不会再变了。以下的内容均结合node的异步操作来说明 简单使用Promise是一个构造函数，首先要创造一个Promise实例。 12345678910111213var promiseOne = new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; //容器中的任务失败了，把容器中的pending状态变为rejected reject(err) //调用reject就相当于调用了then方法的第二个参数函数 &#125; else &#123; //容器中的任务成功了， 把容器中的pending状态变为resolved resolve(data) //也就是说这里调用的resolve方法实际就是then方法传递的那个function &#125; &#125;)&#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 1234567promiseOne.then(function (data) &#123; //成功 console.log(data)&#125;, function (err) &#123; //失败 console.log(err)&#125;) then方法接收两个回调函数，第一个回调函数即调用上文中的resolve（data），第二个回调函数可选，即调用上文中的rejecte（err） 简单封装Promise版本的readFile方法1234567891011121314151617181920212223242526var fs = require('fs')function promiseReadFile(filePath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;promiseReadFile(filePath) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) &#125;)]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>-ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose简单操作]]></title>
    <url>%2F2018%2F06%2F10%2FMongoose%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装1npm install mongoose 快速上手1.引入mongoose模块1var mongoose = require('mongoose'); 2.定义一个Schema：一种以文件形式存储的数据库模型骨架1var Schema = mongoose.Schema 3.连接数据库,指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来(myserver是自己创建的)1mongoose.connect('mongodb://localhost/myserver') 4.设计文档结构，官方文档的123456789101112var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 这里我用这样的来做简单例子12345678910111213var userSchema = new Schema(&#123; username:&#123; type: String, require: true &#125;, password:&#123; type: String, require: true &#125;, email:&#123; type:String &#125;&#125;) 5.将Shcema发布为model mongoose.model 方法就是用来将Shcema发布为 model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称例如这里的 User 最终会变为 users 集合名称 第二个参数：架构 Schema 返回值：模型构造函数1var User = mongoose.model('User',userSchema) 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行增删改查了 增加数据1234567891011121314var admin = new User(&#123; username:'张三', password:'12345', email:'email@email.com'&#125;)admin.save(function(err,ret)&#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功'); console.log(ret) &#125;&#125;) 查询数据查询所有123456789User.find(function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 按条件查询所有1234567891011User.find(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 查询一个1234567891011User.findOne(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 删除数据按条件删除所有1234567891011User.remove(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功'); console.log(ret) &#125;&#125;) 按条件删除一个:与上面相似1Model.findOneAndRemove(condition,[option],[callback]) 根据id删除一个1Model.findByIdAndRemove(id,[option],[callback]) 更新数据根据id更新一个1234567891011User.findByIdAndUpdate('xxxxxx',&#123; username:'李四'&#125;,function(err,ret)&#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功'); console.log(ret) &#125;&#125;) 根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个1Model.findOneAndUpdate(conditions,update,[options],[callback])]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
