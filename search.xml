<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[了解一点HTTP(四)之HTTP状态码]]></title>
    <url>%2F2018%2F09%2F23%2F%E4%BA%86%E8%A7%A3%E4%B8%80%E7%82%B9HTTP(%E5%9B%9B)%E4%B9%8BHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[文章基于《图解HTTP》 HTTP状态码是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端是正常处理了请求还是出现李错误 状态码的类别 类别 原因短语 1XX 信息性状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 冲定向状态码 需要附加操作以完成请求 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器错误状态码 服务器处理请求出错 2XX 成功200 状态码客户端发来的请求在服务端被正常处理了 204 状态码代表服务端接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般在只需要从客户端网服务器发送信息，而对客户端不需要发送新信息的情况下使用 206 状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求 3XX 重定向301 状态码永久性重定向，表示资源已被分配了新的URI，以后应使用资源现在所指的URI 302 状态码临时重定向。表示资源已被分配了新的URI，用户 本次 能使用新的URI 303 状态码表示请求对应的资源存在值另一个URI，应使用 GET 请求方法定向获取请求的资源。 301，302，,303状态码返回时，几乎所有的浏览器都会把POST改成GET。即使301，,302标准禁止将POST改成GET 304 状态码表示客户端附带条件请求时，服务端允许访问资源，但未满足条件的情况。 307 状态码临时重定向。区别在于307状态码不会从POST变成GET 4XX 客户端错误400 状态码表示请求报文中存在语法错误。 401 状态码表示请求需要通过HTTP认证的认证信息。若之前已进行过一次请求，则表示用户认证失败 403 状态码表示请求资源的访问被服务器拒绝了。 404 状态码表示服务器上无法找到请求的资源 5XX 服务器错误500 状态码表示服务器在执行请求时发生了错误。 503 状态码表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 注意 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码还是返回200。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解一点HTTP(三)之HTTP报文]]></title>
    <url>%2F2018%2F09%2F21%2F%E4%BA%86%E8%A7%A3%E4%B8%80%E7%82%B9HTTP(%E4%B8%89)%E4%B9%8BHTTP%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP报文用于HTTP协议交互的信息称为报文。客户端的叫请求报文，服务端的叫响应报文HTTP报文可分为报文首部和报文主体。 报文结构请求报文和响应报文的首部结构 请求报文 响应保卫 请求行 状态行 请求首部字段 响应首部字段 通用首部字段 通用首部字段 实体首部字段 实体首部字段 其他 其他 请求行包含用于请求的方法，请求的URI和HTTP版本 状态行包含表明响应结果的状态码，原因短语和HTTP版本 首部字段包含表示请求和响应的各种条件和属性的各类首部 其他可能包含HTTP的RFC里未定义的首部（Cookie）等 使用编码传输HTTP在传输数据时可以进行编码传输，可以提升速率，但消耗CPU资源 报文主体和实体主体的差异报文的主体用于传输请求或响应的实体主体。通常两者是相等的。但若传输中进行了编码操作就会导致不同 内容编码和分块传输编码内容编码：将数据进行压缩传输，有客户端接收并进行解码 分块传输编码：在HTTP通信时，将大容量数据分割成多块，让浏览器逐步显示页面 发送多种数据的多部分对象集合类似平常发邮件，可以添加多份附件，比如图片，文本，视频。HTTP也使用射中方法，叫做多部分对象集合方法。发送的报文主体可以包含多类型实体。多用于图片文本的上传。 获取部分内容的范围请求HTTP允许请求指定范围的资源。指定范围发送的请求叫做范围请求。 内容协商返回最合适的内容当浏览器的默认语言是英文或中文，访问相同的网页就会显示相应的英文页面或中文页面，这就是内容协商，即客户端与服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源 内容协商有3种类型： 服务器驱动协商：由服务器进行内容协商 客户端驱动协商：由客户端进行内容协商 透明协商：服务器驱动和客户端驱动相结合]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解一点HTTP(二)]]></title>
    <url>%2F2018%2F09%2F20%2F%E4%BA%86%E8%A7%A3%E4%B8%80%E7%82%B9http%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文章基于《图解HTTP》 简单的HTTP协议客户端与服务器之间的通信客户端和服务器之间通过HTTP协议进行通信，客户端发送请求，服务器回复响应。 请求报文：由请求方法，请求URI、协议版本、可选的请求首部字段和内容实体构成。 响应报文：由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体 HTTP是不保存状态的协议HTTP协议不对请求和响应之间的状态进行保存，即不做持久化处理。比如用户登录一个网站，当离开当前页面后，第二次再回到此页面不会保持登录状态了，针对这个问题，于是有了Cookie技术。 Cookie技术Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。 Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时客户端会自动在请求报文中加入Cookie值后发送出去。服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的链接请求，然后比对服务器上的记录，最后得到之前的状态信息。 HTTP方法 GET方法：用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应内容 POST方法：用来传输实体的主体。 PUT方法：用来传输文件。要求在请求报文的主体中包含文件内容，但因其自身不带验证机制，所以一般不使用。但可以配合Web应用程序的验证机制。 HEAD方法：只获得报文的首部，来确认URI资源的有效性即资源更新的日期时间。 DELETE方法：删除文件，与PUT相反的方法。自身也不带验证机制 OPTION方法：询问服务端支持哪些方法 TRACE方法：追踪路径。用来确认链接过程中发生的一系列操作。在发送请求时，在Msx-Forwards首部字段填入数值，每经过一个服务器端就将该数字减1，当减到0就停止传输。最后接受到请求的服务器端则返回200 OK的响应。此方法容易引起XST（跨站追踪）攻击。 CONNECT方法：要求用隧道协议链接代理。与代理服务器通信时建立隧道，使用SSL（安全套接字）和TLS（传输层安全）协议将通信内容加密后经网络隧道传输。 格式：CONNECT 代理服务器名：端口号 HTTP版本 持久连接HTTP协议初期没进行一次通信就要断开一次TCP连接，资源一多大大增加了通信量的开销。后来则改成了持久连接，只要任意一端没有明确提出断开连接，则保持TCP连接状态。 管线化持久连接使得多数请求可以以管线化方式发送。管线化技术即不用等待响应亦可发送下一个请求，这样就可做到同时并行发送多个请求。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css居中问题]]></title>
    <url>%2F2018%2F09%2F20%2Fcss%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如何让一个不定宽高的子盒子，垂直水平居中HTML结构： 123&lt;div class="parent"&gt; &lt;div class="child"&gt;垂直水平居中&lt;/div&gt; &lt;/div&gt; CSS 12345.parent&#123; width: 200px; height: 200px; background-color: skyblue;&#125; 使用flex（最简单）123456.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 使用css方法1234567891011.parent &#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.child&#123; display: inline-block; vertical-align: middle; &#125; 使用css3方法12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解一点http(一）]]></title>
    <url>%2F2018%2F09%2F19%2F%E4%BA%86%E8%A7%A3%E4%B8%80%E7%82%B9http(%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文章基于《图解HTTP》 网络基础TCP/IPTCP/IP协议族不同硬件、操作系统之间的通信都需要规则，这些规则称之为协议。而TCP/IP是互联网相关联的协议族的总称 TCP/IP的分层TCP/IP协议族分为四层：应用层、传输层、网络层、数据链路层。 应用层应用层决定了向用户提供应用服务时通信的活动。预存了各类通用的应用服务。如FTP和DNS。HTTP协议也处于该层 传输层为上层的应用层提供数据传输。有TCP(传输控制协议)和UCP(用户数据报协议) 网络层用于处理网络上流动的数据包。规定通过怎样的传输路线能到达对方计算机。作用就是在众多的选项中选择一条传输路线。 数据链路层处理连接网络的硬件部分。硬件上的范畴均在链路层的作用范围之内 TCP/IP通信传输流一张图很好的说明了客户端如何向服务端发送请求 发送端在层与层传输数据时，每经过一层时必定会打上一个该层所属的首部信息。反之，结束端则会将相应的首部消去 三个重要的协议IP协议位于网络层，满足各类条件确保将数据包传送给对方。两个重要的条件： IP地址指明了节点被分配到的地址，依赖MAC地址 MAC地址网卡所属的固定地址，与IP地址进行配对，搜索下一个中转目标ARP协议可以根据IP地址解析出相应的MAC地址 TCP协议位于传输层，将大块数据分割成以报文段为单位的数据包，从而更加准确的将数据发送给对方。著名的三次握手策略：若某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包 DNS服务位于应用层的协议，提供域名到IP地址之间的解析服务。DNS协议可以通过域名找到IP地址，也可以从IP地址反查到域名 各种协议与HTTP协议的关系一张图概括： URI和URLURL(统一资源定位符)即我们输入地址栏的网页地址 URI(统一资源标识符)由某个协议方案表示的资源的定位标识符。协议方案即访问资源所使用的协议类型的名称 两者关系URI用字符串标识某一互联网资源，而URL表示资源的地点。所以URL是URI的子集。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo构建博客]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%88%A9%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基本步骤 1.基于node 2.npm包管理工具 3.npm install -g hexo(hexo-cli) 4.下载的资源是国外的可能比较慢 5.淘宝镜像（代理的仓库） 6.npm install -g hexo –registry=https://registry.npm.taobao.org 7.在一个空目录（hexo init）博客系统的初始化 8.hexo\source_posts md文档就是博客文档 9.如果要写一篇博客（新建文件 xxx.md） 10.把md文档转html文件（hexo g） 11.在自己的服务器预览（hexo s） localhost:4000 12.如果从新生成html文件可能会有缓存 （hexo clean,hexo g） 13.和github关联 推代码到github 14.和git关联 hexo-deploy-git 插件（安装 npm install hexo-deployer-git –save ） 15.和github关联需要配置文件 16.修改文件 _config.yml 在最下面 17. type: git repo: git@github.com:用户名/用户名.github.io.git branch: master 18.需要在github配置仓库 名称（用户名.github.io） 19.把代码推到github (hexo d) 20.只能预览代码 无法预览页面 21.配置当前仓库可以通过网络访问页面 22.在仓库的首页 settings—&gt;GitHub Pages–&gt;改选项 Source（none—master branch） 23.通过 用户名.github.io 访问你的博客]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git简单使用]]></title>
    <url>%2F2018%2F09%2F18%2Fgit%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git的三个区工作区-&gt;暂存区-&gt;版本库（这三个都是本地完成的） 常见git命令：同步到远程基本操作步骤 1.git init：初始化。在项目的文件夹添加.git文件夹 2.git add：添加监视。git add –all：添加全部，添加到暂存区中 3.git commit -m “描述语言”：提交到版本库。add和commit可一起写：git commit -a -m “描述” 4.git remote add origin https://github.com/Zsuz/ul.git：和远程链接 origin是名称，可以改，git remote -v：可查看origin相应的远程地址 5.git push -u origin master：添加到远程中（-u表示以流的方式，速度比较快，没有也可以） 查看 git status：查看状态 git log：查看提交的日志，一次显示不全可以敲回车看，q键可退出 对比 git diff：查看几次提交的不同（工作区和暂存区的差异） git diff –cached（–staged）：暂存区和版本库的差异 git diff master：工作区和版本库之间的差异，master为分支 撤销 git reset HEAD &lt;file.name&gt;（从暂存区撤销到工作区） git checkout – &lt;file.name&gt;：工作区回到版本库区的内容（先会在暂存区进行撤销操作，没有的话再到版本库 git commit –amend：撤销上一次的提交，再加一些文件一起提交 删除 git rm &lt;file.name&gt;：删除暂存区中的文件（若工作区已经删除可执行，若工作区没有删除，则要执行以下命令） git rm -f &lt;file.name&gt;:将工作区和暂存区的对应文件都删除了； git rm –cached &lt;file.name&gt;：将暂存区的文件删除，工作区的仍然还在 git rm raindow -r -f ：删除raindow文件夹及其以下的文件 恢复 git reset –hard id：返回到指定一个版本，xx表示哈希值，从日志中可以查到，随便拷几个就行 git checkout id &lt;file.name&gt;：误删文件之后恢复某个文件 git reset –hard HEAD^：回到当前版本的上一个版本。HEAD相当一指针 git reset –hard HEAD~2：回到上两个版本 git reflog查询回到版本的操作，然后在使用git reset –hard id 多人协作同步和解决冲突 git fetch：拉取远端的文件，但不进行合并，要进行手动的合并 git diff master origin/master:查看本地和远端的不同手动合并：git merge origin/master git pull：拉取并自动合并了本地代码 开源项目协作 fork:在github克隆一个整体的版本放到当前用户名下 pull request：向所有者请求 git分支 git branch：查看分支 git branch new1：创建new1分支 git checkout new1 ：切换到new1分支 简写：git checkoout -b new1：创建分支并切换到该分支 git merge new1：与new1分支合并 git branch –merged：查看当前分支它下边所合并的分支 git branch –no-merged：没有与当前分支合并的分支 git branch -d new1：已经合并了，可以删除new1分支。没有合并的分支，不能通过-d方式删除，换成-D即可删除没有合并的分支 打标签/版本（release）:git tag v1.0, 同步到远端：git push origin v1.0 起别名：git config –global alias.co checkout(将checkout用co代替 github gist：存储小的代码片段 创建博客 演示文档：pages.github.com 创建仓库名要与用户名相同]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散阅读]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%A4%A7%E6%9D%82%E7%83%A9%E4%B9%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[此文章并不是围绕一个主题来展开的，只是日常的零散时间，碰到一些知识，在此做个记录。 作用域问题在看到一个有意思的例子： 1234567var a = 123;function f()&#123; console.log(a); //undefined var a = 1; console.log(a); //1&#125;f(); 刚看到时以为不就是打印123和1吗，但结果确实第一次打印undefined，第二次是1，为什么呢。这跟作用域有关，第一次显示undefined，是因为函数域始终优先于全局域，所以局部变量a会覆盖所有与它同名的全局变量。这就知道为什么第一次调用console.log()会打印undefined了，因为a还没有被正式定义。 函数的return子句函数通常都有返回值，如果某个函数没有显式的返回值，则默认它的返回值为undefined]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单总结JavaScript原型与原型链]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[prototype每个函数都有一个prototype属性，指向实例的原型。是构造函数和实例原型之间的桥梁。 _proto_除了null外，每一个JavaScript对象都有一proto个属性，指向该对象的原型。proto属性连接着实例与实例原型 constructor每个原型都有一个constructor属性，指向关联的构造函数 原型的原型原型对象是通过Object构造函数生成的。即Object.prototype。而Object.prototype的原型为null 用一张图表示他们之间的关系]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端分辨率问题]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%86%E8%BE%A8%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为什么移动端给出宽750px的设计图。在编写代码时确是375px？先来看一张表 设备 屏幕尺寸 分辨率（pt） reader 分辨率（px） PPI（DPI） iphone 3GS 3.5寸 320 x 480 @1x 320 x 480 163 iphone 4/4S 3.5寸 320 x 480 @2x 640 x 960 326 iphone 5/5S/5C 4.0寸 320 x 568 @2x 640 x 1136 326 iphone 6/6S 4.7寸 320 x 667 @2x 320 x 480 326 iphone 6/6S plus 5.5寸 320 x 736 @3x 1242 x 2208 401 pt逻辑分辨率，也可以简单理解是长度单位，即视觉单位，我们可以看到的，它是与屏幕尺寸有关系 px物理分辨率，与屏幕的尺寸没有关系。像素，屏幕上实际的像素点单位。我们看到的图片等都是一个一个像素点构成的 pt与px的关系可以理解为一个pt由几个px构成。这里就能够解释为什么iPhone4比iphone3GS更清晰：它与一个逻辑分辨率包含几个物理像素点有关。这里iPhone4的物理分辨率高，是二倍的关系，也是reader是二倍关系，这里的reader就表示同一个pt下包含几个px。同一个单位下物理像素点 越多就越清晰。 这里要注意的是iPhone6plus按理应该会比iPhone6更清晰才对，但是6plus并不会更清晰。人类眼睛能分辨出来的是有限度的，当达到两个，就已经是人眼能分辨的极限了，再增加像素点就没有用了， PPI（DPI）即像素密度，表示每英寸包含几个像素点。可以根据勾股定理算出来，物理分辨率分平方和再开方，得到的结构除以屏幕的尺寸可以得出来。 这里也可以解释为什么经常UI设计图给出的是宽750的设计图，而iPhone6用375宽。移动端给出的是逻辑分辨率，而设计图都是根据物理分辨率的。iPhone6的逻辑分辨率和物理分辨刚好是二倍的关系 注意 很多设计图都是根据iPhone6给的，iPhone6下2个px才构成一个pt。 小程序如何做不同分配率设备的自适应 以iPhone6的物理像素750 x 1334为视觉稿进行设计，在小程序中用rpx为单位 iPhone6下1px = 1rpx = 0.5 pt 使用rpx，小程序会自动在不同的分辨率先进行转换，使用px就没有这种效果 推荐用iPhone6的物理分辨率来做设计图，因为iPhone6下1px = 1rpx。比较简便]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之面向对象(二)]]></title>
    <url>%2F2018%2F09%2F06%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[继承原型链基本思想：让一个原型对象等于另一个类型的实例，从而实现继承。此时原型对象包含一个指向另一个原型的指针，另一个原型也包含着一个指向另一个构造函数的指针。如果另一个原型又是另一个类型的实例，如此层层递进，就构成了实例与原型的链条，即原型链。 123456789101112131415161718function Parent()&#123; this.name = 'parentName';&#125;Parent.prototype.getParentName = function()&#123; return this.name;&#125;function Child()&#123; this.childname = 'childName';&#125;//继承了ParentChild.prototype = new Parent();Child.prototype.getChildName = function()&#123; return this.childname;&#125;var child1 = new Child();console.log(child1.getParentName()); //parentName 通过创建Parent实例，并将实例赋给Child.prototype实现继承。本质上就是重写了原型对象，用一个新类型的实例取代它。 此时的getParentName()方法仍在Parent.prototype中，但name则位于Child.prototype中。因为name是一个实例属性，而getParentName()则是一个原型方法。既然Child.prototype现在是Parent的实例，那name就应该在该实例中。需要注意的是。 注意 child1.constructor现在指向Parent 搜索属性要经历三个步骤 搜索实例 搜索Child.prototype 搜索Parent.prototype 给原型添加方法的代码一定要放在替换原型的语句之后 通过原型链实现继承时，不能使用对象的字面量创建原型方法，以为这样会重写原型链 确定原型和实例的关系可以使用instanceof操作符和isPrototypeOf()方法来确定 12345678//instanceof操作符来测试实例与原型链中出现过的构造函数console.log(child1 instanceof Object); //trueconsole.log(child1 instanceof Child); //trueconsole.log(child1 instanceof Parent); //true//原型链中出现的原型都可以说是该原型链所派生的实例的原型console.log(Object.prototype.isPrototypeOf(child1)); //trueconsole.log(Child.prototype.isPrototypeOf(child1)); //trueconsole.log(Parent.prototype.isPrototypeOf(child1)); //true 存在的问题： 包含引用类型值的属性会被所有实例共享，在原型链实现继承时，原型实际上会变成另一个类型的实例，原先的实力属性就变成了原型属性。 不能向父类的构造函数中传递参数 构造函数实现继承基本思想：在子类型构造函数的内部调用父类型的构造函数 1234567891011121314151617function Parent(name)&#123; this.name = name; this.friends = ['rose','mick','jucy']&#125;function Child()&#123; //继承Parent,同时传递了参数 Parent.call(this,'jack');&#125;var child1 = new Child();child1.friends.push('ham');console.log(child1.friends); //["rose", "mick", "jucy","ham"] var child2 = new Child(); //["rose", "mick", "jucy"]console.log(child2.friends)console.log(child1.name); //jack 存在的问题： 方法都在构造函数中定义了，没有了函数的复用性 组合继承基本思想将原型链和构造函数组合在一起，即使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。 123456789101112131415161718192021222324252627282930function Parent(name)&#123; this.name = name; this.friends = ['rose','mick','jucy'];&#125;Parent.prototype.sayName = function()&#123; console.log(this.name)&#125;;function Child(name,age)&#123; //继承属性 Parent.call(this,name); this.age = age;&#125;;//继承方法Child.prototype = new Parent();Child.prototype.constructor = Child;Parent.prototype.sayAge = function()&#123; console.log(this.age)&#125;var child1 = new Child('jack',18);child1.friends.push('ham');console.log(child1.friends); //["rose", "mick", "jucy", "ham"]child1.sayName(); //jackchild1.sayAge(); //18var child2 = new Child('dom',25);console.log(child2.friends); ["rose", "mick", "jucy"]child2.sayName(); //domchild2.sayAge(); //25 存在的问题无论什么情况下都会调用两次父类的构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。最终子类型会包含父类型对象的全部实例属性。然后又不得不重写这些这些属性，可以使用寄生组合式继承解决。 原型式继承基本思想没有严格意义上的构造函数，借助原型可以基于已有的对象创建新对象。 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 在object()函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的新实例。 1234567891011121314var person = &#123; name:'jack', friends:['rose','mick','jucy']&#125;;var onePerson = object(person);onePerson.name = 'ham';onePerson.friends.push('simen');var twoPerson = object(person);twoPerson.name = 'dom';twoPerson.friends.push('ruma');console.log(person.friends); //["rose", "mick", "jucy", "simen", "ruma"] Object方法规范化了原型式继承，接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 123456789101112131415161718var person = &#123; name:'jack', friends:['rose','mick','jucy']&#125;;//ie要9以上支持此方法var onePerson = Object.create(person,&#123; name:&#123; value:'ham' &#125;&#125;);console.log(onePerson.name); //hamonePerson.friends.push('simen');var twoPerson = Object.create(person);twoPerson.name = 'dom';twoPerson.friends.push('ruma');console.log(person.friends); //["rose", "mick", "jucy", "simen", "ruma"] 寄生式继承基本思想创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象。 123456789101112131415function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; console.log('hi'); &#125;; return clone&#125;var person = &#123; name:'jack', friends:['rose','mick','jucy']&#125;;var onePerson = createAnother(person);onePerson.sayHi(); //'hi' 在主要考虑对象而不是自定义类型和构造函数的情况下，可以使用这种模式，任何能够返回新对象的函数都是适用于此模式。 存在的问题不能做到函数的复用性，从而会降低效率。与构造函数类似 寄生组合式继承基本思想借用构造函数来继承属性，通过原型链的混合形式来继承方法。这样就不必为了指定子类型的原型而调用超类型的构造函数。即使用寄生式继承来继承超类型的原型，然后再将结构指定给子类型的原型。 123456789101112131415161718192021222324252627function inheritPrototype(child,parent)&#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;;function Parent(name)&#123; this.name = name; this.friends = ['rose','mick','jucy'];&#125;Parent.prototype.sayName = function()&#123; console.log(this.name)&#125;;function Child(name,age)&#123; //继承属性 Parent.call(this,name); this.age = age;&#125;;inheritPrototype(Child,Parent);Child.prototype.sayAge = function()&#123; console.log(this.age)&#125;var child1 = new Child('jack',18);console.log(child1.name); //jack]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之面向对象(一)]]></title>
    <url>%2F2018%2F09%2F04%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[创建对象工厂模式用函数来封装以特定接口来创建对象 12345678910111213function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var person1 = createPerson('jack',18,'teacher');var person2 = createPerson('rose',19,'doctor'); 存在的问题：没有解决对象的识别问题，即不能知道一个对象是什么类型 构造函数模式与工厂模式的不同： 没有显式地创建对象 直接将属性和方法赋给了this对象 没有return语句 1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name) &#125;&#125;var person1 = new Person('jack',18,'teacher');var person1 = new Person('rose',19,'doctor'); 函数名以大写开头，用于区别其他函数。 使用new创建新实例来调用构造函数必须经历一下四个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 使用构造函数模式可以使用instanceof操作符来检测对象类型，这也正是构造函数胜过工厂模式的地方。 任何函数，只要通过new操作符来调用，那它就可以作为构造函数；不通过new操作符来调用，跟普通函数没什么区别，若不使用new操作符调用构造函数，则属性和方法都被添加给window对象了 12Person('jack',18,'teacher');window.sayName(); //jack 存在的问题：每个方法都要在每个实例上重新创建一遍。如person1和person2都有sayName方法，两个方法不是同一Function的实例，而创建两个同样任务的Function实例是没有必要的 原型模式使用prototype属性实现 12345678910function Person()&#123;&#125;;Person.prototype.name = 'jack';Person.prototype.age = 18;Person.prototype.job = 'teacher';Person.prototype.sayName = function()&#123; console.log(this.name)&#125;var person1 = new Person();person1.sayName(); //jack 可以使用字面量形式简写： 123456789function Person()&#123;&#125;;Person.prototype = &#123; name:'jack', age:18, job:'teacher', sayName:function()&#123; console.log(this.name) &#125;&#125; 采用这种写法，constructor属性不再指向Person，指向Object构造函数 1234//第一种写法console.log(Person.constructor); //Person()&#123;&#125;//第二种写法console.log(Person.constructor); //Object() &#123; [native code] &#125; 原型对象只要创建一个函数，就会为该函数创建一个prototype属性，指向函数的原型对象。原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。如Person.prototype.constructor指向Person 创建自定义的构造函数后，其原型对象默认只会取得constructor属性，其他属性和方法都是从Object继承而来的，当调用函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。这个指针即[[prototype]],它是没办法访问的，但每个对象都支持属性_proto_,其他浏览器不可见。这个指针是 存在实例与构造函数的原型对象之间 isPrototypeOf()方法和getPrototypeOf()方法虽然无法访问[[prototype]]，但可以通过isPrototypeOf()方法和getPrototypeOf()方法来确定对象之间是否存在这种关系 12console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Object.getPrototypeOf(person1) == Person.prototype) //true hasOwnProperty()方法用于检测一个属性存在于实例中还是存在于原型中，只在给定属性存在于对象实例中，才会返回true 注意： 在调用对象的属性或方法时，会先后执行两次搜索。第一次搜索会先从对象实例本身开始，若找到则返回该值，若没有找到，会顺着指针在原型对象中查找，找到即返回。 不能通过对象实例重写原型中的值，如果实例中的属性和原型的属性同名，实例中的属性会屏蔽原型中的属性。使用delete可以删除实例属性，就可以重新访问原型中的属性了。 存在的问题：因为原型模式的共享性，导致它存在的问题：并不是所有实例都希望共享所有的属性方法，实例一般都是要有属于自己的去不属性的 组合使用构造函数模式和原型模式————最广泛使用的一种组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性 12345678910111213141516171819202122function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ['mick','xiao'];&#125;Person.prototype = &#123; sayName:function()&#123; console.log(this.name) &#125;&#125;var person1 = new Person('jack',18,'teacher');var person2 = new Person('rose',19,'doctor');person1.friends.push('jucy');console.log(person1.friends); //["mick", "xiao", "jucy"]console.log(person2.friends); //["mick", "xiao"]console.log(person1.friends == person2.friends); //falseconsole.log(person1.sayName == person2.sayName); //true 此时修改person1.friends，不会影响到person2.friends。若采用原型模式则无法做到这点 动态原型模式将所有信息都封装在构造函数中，在构造函数中初始化原型。 1234567891011121314function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; if(typeof this.sayName != 'function')&#123; Person.prototype.sayName = function()&#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person('jack',18,'teacher');person1.sayName() 注意： 不能适用对象字面量重写原型，这样会切断现有实例与原型之间的联系 寄生构造函数模式基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。 12345678910111213function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var person1 = new Person('jack',18,'teacher');person1.sayName() 注意 寄生构造函数模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。因此不能依赖instanceof操作符来确定对象类型。所以尽量不要使用这种模式 稳妥构造函数模式在一些禁止使用this和newde安全环境中使用。 1234567891011function Person(name,age,job)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name) &#125;; return o;&#125;var person1 = Person('jack',18,'teacher');person1.sayName() 这种模式只能通过方法来访问其数据成员，如只能通过调用sayName()方法来访问name。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、jQuery中的事件和动画]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%9B%9B%E3%80%81jQuery%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[1.jQuery中的事件事件绑定bind()方法：bind(type,[data],fn),可多次调用 合成事件hover(enter,leave)方法:光标移动到元素上enter，触发第一个函数，移除触发第二个函数leave。相当于替代了bind(‘mouseenter’)和bind(‘mouseleave) toggle(fn1,fn2,…fnN)方法：第一次点击元素触发第一个函数，第二次触发第二个函数… 另一个用法是切换元素的可见状态，用于显示和隐藏： 1234567$(function()&#123; $(#btn).toggle(function()&#123; $(this).next().toggle() &#125;,function()&#123; $(this).next().toggle() &#125;)&#125;) 事件冒泡 阻止事件冒泡：stopPropagation()方法 阻止默认行为：preventDefault()方法。 preventDefault()方法能阻止表单的提交行为，如果想同时对事件对象停止冒泡和默认行为，可以用return false方式 注意：jQuery不支持事件捕获 常见事件对象的属性（1）event.type属性：获取事件类型 （2）event.stopPropagation()方法：阻止冒泡 （3）event.preventDefault()方法：阻止默认的事件行为 （3）event.taget属性：获取触发事件的元素 （3）event.pageX/event.pageY属性：获取光标相对于页面的x坐标和y坐标。不用jQuery有兼容性问题（3）event.which属性：在鼠标单击事件中获取到鼠标的左，中，右键，返回1,2,3；在键盘事件中获取键盘的按键 （3）event.metaKey属性： 移除事件模拟事件其他用法2.jQuery中的动画简单方法自定义动画方法]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、存储器管理]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%9B%9B%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[存储器的层次结构计算机的存储层次分为三层，三层中还可以再细分 最高层为CPU寄存器 寄存器 中间为主存 高速缓存 主存储器 磁盘缓存 最底层是辅存。 固定磁盘 可移动存储介质 主存储器：简称内存或主存，用于保存进程运行时的程序和数据 寄存器：具有与处理机相同的速度，访问速度很快，能与CPU协调工作，但价格昂贵，容量小 高速缓存：介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存的访问次数 磁盘缓存：用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的速度 程序的装入和链接用户程序要在系统中运行，就必须先装入内存，然后在将其转变为一个可以执行的程序，通常要经过以下步骤 编译 链接 装入 1.装入方式 绝对装入 可重定向装入 2.链接 静态链接方式：在程序运行前，现将各目标模块及它们所需要的库函数链接成一个完整的装配模块 装入时动态链接：在装入内存时，采用边装入边链接的链接方式 连续分配存储管理方式对换分页存储管理方式分段存储管理方式]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、处理机调度与死锁]]></title>
    <url>%2F2018%2F08%2F28%2F%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[处理机调度的层次和调度算法的目标1.处理机调度的层次 高级调度：调度对象是作业，主要用于多道批处理系统中 中级调度：即内存调度。目的是提高内存的利用率和系统的吞吐率 低级调度：调度对象是进程 作业与作业调度1.作业概念：作业不仅包含了通常的程序和数据，而且还应配有一份作业说明说，系统根据说明书来对程序的运行进行控制。 主要任务：根据作业控制块中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它创建进程，分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度 2.作业调度先来先服务调度算法：优先考虑在系统中等待时间最长的作业，不管该作业所需执行时间的长短。 短作业优先的调度算法：以作业的长短计算优先级，作业越短，其优先级越高 进程调度1.任务 保存处理机的现场信息 按某种算法选取进程 吧处理器分配给进程 2.调度机制 排队器：事先将就绪进程按一定策略排队 分派器；将处理机分配给选到的进程 上下文切换器：进行上下文切换 3.进程调度方式3.1非抢占方式一旦把处理机分配给某个进程时，就一直让它进行下去，不会因为中断请求等将去抢占正在运行进程的处理机。 3.2.抢占方式允许调度程序根据某些规则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程 遵循一定的原则： 优先权原则 短进程优先原则 时间片原则 死锁概述1.定义如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，则该组进程是死锁的 可抢占资源是不会引起死锁的，像CPU、主存等 不可抢占资源会引起死锁，像磁带机，打印机等 2.产生的条件同时具备以下四个条件 互斥条件 请求和保持条件 不可抢占条件 循环等待条件 3.处理死锁的方法 预防死锁 避免死锁 检测死锁 解除死锁 预防死锁原理：因为互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，所以主要是破坏产生死锁的后三个条件 1.破坏“请求和保持”条件保证当一个进程在请求资源时，它不能持有不可抢占资源。通过两种协议实现这种保证 规定所有进程在开始运行前，必须一次性的申请其在整个运行过程中所需的全部资源 允许一个进程只获得运行初期所需的资源后，便开始运行，然后在逐步的边释放边请求资源 2.破坏“不可抢占”条件规定当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请 3.破坏“循环等待”条件对系统所有资源类型进行线性排序，进程只能按编号顺序来请求资源。 避免死锁在程序运行时避免发生死锁，确保系统始终出于安全状态 1.安全状态指系统能某种进程推进顺序为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。 2.利用银行家算法避免死锁刚开始是为银行系统设计的，确保银行在发放现金贷款是，不会发生不能满足所有客户需要的情况 2.1.银行家算法中的数据结构 可利用资源向量Available。一个含有m个元素的数组 最大需求矩阵Max。一个n x m的矩阵。定义n个进程中的每一个进程对m类资源的最大需求 分配矩阵Allocation。一个n x m的矩阵。定义系统中每一类资源当前已分配给每一道进程的资源数 需求矩阵Need。一个n x m的矩阵。表示每一个进程尚需的各类资源数 2.2.银行家算法步骤： 1.如果Request &lt;= Need,转向步骤二，否则出错 2.如果Available &lt;= Allocation，转向步骤三，否则等待 3.系统试探把资源分配给进程，并修改下面数值 Available = Available - Request Allocation = Allocation + Request Need = Need - Request 4.系统执行安全性算法，处于安全状态则分配 2.3.安全性算法 1.设置两向量： （1）工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，刚开始Work = Available。 （2）Finish：表示系统是否有足够的资源分配给进程，刚开始Finish = false 2.从进程集合找到一个满足下述条件的进程，若找到，转到步骤3，否则转到步骤4 Finish = false Need = Work 3.当进程获得资源后。可顺利执行，直至完成，并释放出分配给它的资源，故执行 Work = Work + Allocation Finish = true go to step2 4.如果所有进程的Finish = true都满足，则表示系统处于安全状态。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、jQuery中的DOM操作]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%89%E3%80%81jQuery%E4%B8%AD%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.查找节点1.1.查找元素节点和属性节点1234// 获取ul元素里第2个li节点var $li = $('ul li:eq(1)');// 查找属性用arrt()方法var p_txt = $('p').arrt('title'); 2.创建节点2.1创建元素，文本，属性节点利用$(html)实现12// 创建一个li标签，包括元素节点'li'，文本节点'新闻'和属性节点'title'var $li = $("&lt;li title='新闻'&gt;新闻&lt;/li&gt;") 3.插入节点3.1.append()方法向每个匹配的元素内部追加内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').append('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt; 3.2.appdendTo()方法将所有匹配的元素追加到指定的元素中，与append()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').appendTo('p')// 结果&lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt; 3.3.prepend()方法向每个匹配的元素内部追前置内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').prepend('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt; 3.4.prependTo()方法将所有匹配的元素前置到指定的元素中，与prepend()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').prependTo('p')// 结果&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt; 3.5.after()方法在每个匹配的元素之后插入内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').after('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; 3.6.insertAfter()方法将所有匹配的元素插入到指定的元素后面，与after()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').insertAfter('p')// 结果&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; 3.7.before()方法在每个匹配的元素之前插入内容 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('p').before('&lt;b&gt;你好&lt;/b&gt;')// 结果&lt;b&gt;你好&lt;/b&gt;&lt;p&gt;我想说：&lt;/p&gt; 3.8.insertBefore()方法将所有匹配的元素插入到指定的元素前面，与after()操作相反 12345678//html代码&lt;p&gt;我想说：&lt;/p&gt;// jq代码$('&lt;b&gt;你好&lt;/b&gt;').insertBefore('p')// 结果&lt;b&gt;你好&lt;/b&gt;&lt;p&gt;我想说：&lt;/p&gt; 4.删除节点4.1.remove()方法删除该节点所包含的所有后代节点 12// 删除ul下的第二个li元素$('ul li:eq(1)').remove(); 4.2.empty()方法清空该节点所包含的所有后代节点 12// 清空ul下的第二个li元素里的内容，但还剩下li标签默认的符号'·'$('ul li:eq(1)').remove(); 5.复制节点5.1clone()方法在clone()方法中可以传递一个参数true，表示复制元素的同时也复制了元素中的绑定事件 6.替换节点6.1.replaceWith()方法：将匹配到的元素替换成指定的html或dom元素 1$('p').replaceWith('&lt;span&gt;哈哈&lt;/span&gt;') 6.2.replaceAll()方法：与replaceWith()方法作用一致，只是颠倒了replaceWith()操作 1$('&lt;span&gt;哈哈&lt;/span&gt;').replaceAll('p') 7.包裹节点7.1wrap()方法将所有的元素进行一个一个单独包裹 7.3wrapAll()方法将所有匹配到的元素用一个元素包裹 7.3wrapInner()方法将每一个匹配的元素的子内容（包括文本节点）包裹起来 8.属性操作8.1.获取和设置属性attr()方法传一个参数即获取，两个参数即设置 8.2.删除属性用removeAttr()方法 9.样式操作9.1.获取和设置样式用attr(‘class’,’xxx’)实现类名的设置 9.2.追加样式使用addClass()方法操作 9.3.移除样式使用removeClass()方法操作 9.4.切换样式使用toggle()方法操作 9.5.判断是否含有某样式使用hasClass()方法操作 10.设置和获取HTML，文本和值使用html()方法,text()方法和val()方法分别获取HTML，文本和文本框等的值，不传参数是获取，传是设置 11.遍历节点11.1.children()方法取得匹配元素的子元素集合，只考虑子元素不考虑后代元素 11.2.next()方法取得匹配元素后面紧邻的同辈元素 11.3.prev()方法取得匹配元素后面紧邻的同辈元素 11.4.siblings()方法取得匹配元素前后所有的同辈元素 11.5.closest()方法取得最近的匹配元素，先检查当前元素是否匹配，若匹配直接返回元素本身.不匹配向上查找父元素 12.CSS-DOM操作12.1.css()方法12// 可设置多个样式$('p').css(&#123;'fontSize':'30px','backgroundColor':'#666'&#125;) 12.2.offset()方法获取元素在当前视窗的相对偏移，返回top和left两个属性 12// 获取p元素的offset()var offset = $('p').offset() 12.3.position()方法获取相对于最近的一个position样式属性设置为relative或absolute的祖父节点的相对偏移，也返回top和left两个属性 12// 获取p元素的position()var position = $('p').position() 12.4.scrollTop()方法和scrollLeft()方法。分别获取元素的滚动条距顶端的距离和距左侧的距离。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础之引用类型]]></title>
    <url>%2F2018%2F08%2F24%2FJavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.Object类型1.1创建Object实例的两种方法12345678910//第一种：使用Object构造函数的方法var person = new Object();person.name = '张三';person.age = 18;// 第二种：使用对象字面量的形式var person = &#123; person.name = '张三'; person.age = 18;&#125; 1.2访问属性的两种方法12345//第一种：点表示法console.log(person.name);// 第二种：方括号法console.log(person['name']); 属性名中是可以包含非字母非数字的，这时候就可以使用方括号来访问它们。 注意：除非必要使用变量来访问属性，否则我们建议使用点表示法 2.Array类型创建数组也有两种方式：Array构造函数和数组字面量方式 注意： 12var value = [1,2]; //会创建2或3项（ie8以下）var value = [,,,,,]; // 会创建5或6项（ie8以下） 如果将数组的length属性设置大于数组项数的值，则新增的每一次都会取的undefined的值 当把一个值放在超出当前数组大小的位置时，数组就会重新计算其长度值 2.1检测数组2.1.1.instanceof操作符：用法：value instanceof Array存在的问题：假定只有一个全局执行环境才有用 2.1.2.Array.isArray()方法用法：Array.isArray(value) 2.2转换方法2.2.1.toString()方法返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串 2.2.2.valueof()方法返回数组 2.2.3.toLocalString()方法：join()方法:使用不同的分隔符来构建字符串，只接受一个参数， 12var color = ["red","green"];color.join(','); //"red,green" 2.3.栈方法2.3.1.push()添加到末尾，返回修改后的长度 2.3.2.pop()移除最后一项，返回移除的项 2.4.队列方法2.4.1.unshift()数组前端添加任意个项并返回新数组的长度（ie7以下返回undefined） 2.4.2.shift()移除第一项并返回该项 2.5.重排列方法2.5.1.reverse()反转数组 2.5.2.sort()按升序排列 注意： sort()方法会调用每个数组项的toString()转型方法，比较的是字符串 12var value = [0,1,5,10,15];value.sort(); //[0,1,10,15,5] 字符串中"10"位于"5"前 因此若想正确排序，sort()方法可以接收一个比较函数作为参数 123456789101112function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;var value = [0,1,5,10,15];value.sort(compare); //[0,1,5,10,15] 字符串中"10"位于"5"前 2.6.操作方法concat()方法:先创建当前数组一个副本，有参数就添加到副本末尾，返回新构建的数组。不会影响原始数组 slice()方法：接收一或两个参数，不影响原始数组： 一个参数：返回从该参数指定位置开始到当前数组末尾的所有项。 两个参数：返回起始和结束位置之间的项但不包括结束位置的项。 如果参数中有负数，则用数组长度加上该数来确定响应的位置，如对于一个长度为5的数组，调用slice(-2,-1)与调用slice(3,4)是一样的。如果结束位置小于起始位置，则返回空数组 splice()方法:有删除，插入，替换的用途。 删除：两个参数，splice(要删除的第一项的位置,要删除的项数) 插入：三个参数：splice(起始位置，0（要删除的项数），要插入的项数) 替换；三个参数：splice(起始位置，要删除的项数，要插入的项数)，插入的项数与删除的项数不必相等 该方法始终都会返回一数组，包含从原始数组中删除的项（没有删除则返回一个空数组） 2.7.位置方法indexof()方法和lastIndex()方法:这两个方法都接收两个参数：要查找的项和（可选）表示起点位置的索引。其中indexof方法从数组开头开始往后查找，lastIndex方法则从数组末尾向前查找 都返回要查找的项在数组中的位置，没找到返回-1，使用全等操作符 ie9以下不支持 2.8.迭代方法迭代方法都接收两个参数：在每一项上运行的函数和（可选）运行该函数的作用域对象———影响this的值。传入的函数接收三个参数：数组项的值，该项在数组中的位置和数组对象本身 2.8.1.every()方法:如果该函数对 每一项 都返回true，则返回true 2.8.2.filter()方法:返回一个数组，包含该函数会返回true的项。可应用与查询符合某些条件的所有数组项 12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item,index,array)&#123; return (item &gt; 2);&#125;);console.log(filterResult); //[3,4,5,4,3] 2.8.3.forEach()方法:没有返回值 2.8.4.map()方法:返回每次函数调用的结果组成的数组，适用创建包含的项与另一个数组一一对应的数组 2.8.5.some()方法:对数组中的 某一项 返回true，则返回true 2.9.归并方法2.9.1reduce()方法和reduceRight()方法reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()方法则从数组的最后一项开始，向前遍历到第一项。 都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传入的函数接收四个参数：前一个值，当前值，项的索引和数组对象这个函数返回的任何值都会作为第一个参数自动传给下一项。 123456var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; //第一次prev是1，cur是2.第二次prev是3，cur是3 return prev + cur;&#125;);console.log(sum) //15 3.Date类型创建一个日期对象1var now = new Date() 两个方法：Date.parse()和Date.UTC() 3.1.Date.parse()方法:接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，若参数不能表示日期，则返回NaN 3.2.Date.UTC()方法：返回表示日期的毫秒数，参数分别是年份（必需），基于0的月份（必需），月中的哪一天（1到31），小时数（0到23），分钟，秒以及毫秒数 3.3.Date.now()方法:返回调用这个方法时的日期和时间的毫秒数，等同于 +new Date() 。 3.4.日期格式化方法 toDateString()：以特定于实现的格式显示星期几，月，日和年 toTimeString()：以特定于实现的格式显示时，分，秒和时区 toLocaleDateString()：以特定于实现的格式显示星期几，月，日和年 toLocaleTimeString()：以特定于实现的格式显示时，分，秒 toUTCString()：以特定于实现的格式完整的UTC日期 3.5.日期/时间组件方法 getTime(): setTime() getFullYear() setFullYear()…… 4.Function类型每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法，由于函数是对象，因此函数名实际上也是函数对象的指针 4.1.没有重载javascript中没有函数重载的概念，所以若声明了两个同名函数，则后面的函数会覆盖前面的函数 4.2.函数声明与函数表达式解析器在向执行环境中加载数据时，会率先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式，必须等到解析器执行到它所在的代码行，才会被解释执行。在代码执行之前，JavaScript引擎会将函数声明放到源代码树的顶部 123456789console.log(sum(10,10)); //20function sum(num1,num2)&#123; return num1 + num2&#125;console.log(sum(10,10)); //报错var sum = function(num1,num2)&#123; return num1 + num2&#125; 4.3.作为值的函数函数本身就是变量，所以不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数的结果返回。 1234567891011121314151617function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument);&#125;function add10(num)&#123; return num + 10;&#125;var result = callSomeFunction(add10,10);console.log(result); //20function getGreenting(name)&#123; return "hello," + name;&#125;var result2 = callSomeFunction(getGreenting,"jack");console.log(result2); // hello,jack 4.4.函数内部属性函数内部有两个特殊的对象：arguments和this。 arguments：保存函数参数，有一个callee属性，指向拥有这个arguments对象的函数。 函数对象的属性：caller：保存着调用当前函数的函数的引。用，如果在全局作用域中调用当前函数，值为null 1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); //function outer()&#123;inner()&#125;;&#125;outer(); 会打印出outer()函数的源代码，因为outer调用了inner(),所以inner.caller就指向了outer()。 注意：在严格模式下运行，访问arguments.callee会导致错误，而arguments.caller属性无论在严格还是非严格模式都是undefined，定义这个属性主要是为了分清arguments.caller和函数的caller属性 在严格模式下不能为函数的caller属性复制，否则会导致错误 4.5.函数属性和方法属性：length和prototype每个函数都包含两个非继承而来的方法：call()和apply() 这些的用法在另外的文章有专门记录 5.基本包装类型3个特殊的引用类型：Boolean，Number和String。 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象： 12var s1 = "some text";var s2 = s1.substring(2); 正常基本数据类型不应该有方法的，但是它在后台完成一些操作，相当于 123var s1 = new String("some text"); //创建String类型的一个实例var s2 = s1.substring(2); //在实例上调用指定的方法s1 = null; //销毁这个实例 5.1.引用类型和基本包装类型的主要区别主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流结束离开作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，所以不能在运行时为基本类型的值添加属性和方法。 对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true 5.2.Boolean类型重写了valueOf()方法，返回基本类型值true或false，重写toString()和toLocalString()方法，返回字符串”true”和”false” 引用类型的布尔值与基本类型的区别： typeof操作符：基本类型返回”boolean”，引用类型返回”object” instanceof操作符：对Boolean对象返回true，对基本类型返回false 注意： 123var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;console.log(result); //true 布尔表达式的所有对象都会被转为true，所以falseObject为true 5.3.Number类型Number对象是Number类型的实例，基本类型不是 重写了valueOf()方法，返回对象表示的基本类型数值，重写toString()和toLocalString()方法，返回字符串类型数值 5.3.1几个方法： toFixed()：按指定的小数位返回数值的字符串 toExponential()：返回指数表示法 toPrecision()：根据具体情况选择最合适的方法，toFixed()或toExponential() 5.4.String类型5.4.1.字符方法5.4.2.charAt()方法,charCodeAt()方法访问特定字符串中特定的方法，接收一个参数，基于0位置。charAt()方法以单字符字符串返回给定位置的那个字符。charCodeAt()方法返回字符编码 123456var string = "hello world";console.log(string.charAt(1)) //"e"console.log(string.charCodeAt(1)) //"101"//方括号表示法:ie8以下会返回undefinedconsole.log(string[1] //"e" 5.4.3.字符串方法5.4.4.concat()方法字符串拼接，不影响原字符串 5.4.5.slice()方法，substr()方法和substring()方法返回被操作字符串的子字符串，接收一或两个参数，第一个参数为开始位置。第二个参数：slice()方法和substring()方法指定 最后一个字符后面的位置，substr()方法指定返回字符的个数，不影响原字符串 1234567var string = "hello world";console.log(string.slice(3)) //"lo world"console.log(string.substring(3)) //"lo world"console.log(string.substr(3)) //"lo world"console.log(string.slice(3,7)) //"lo w"console.log(string.substring(3,7)) //"lo w"console.log(string.substr(3,7)) //"lo worl" 对于负数：slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，负的第二个参数转换为0。substring()方法会将所有的负数转换为0。 1234567var string = "hello world";console.log(string.slice(-3)) //"rld"console.log(string.substring(-3)) //"hello world"console.log(string.substr(-3)) //"rld"console.log(string.slice(3,-4)) //"lo w"console.log(string.substring(3,-4)) //"hel" 相当于调用substring(0,3)console.log(string.substr(3,-4)) //"" （空字符串） 5.5.字符串位置方法5.5.1.indexOf()方法与lastIndexOf()方法使用方法与Array类型的一致 5.5.2.trim()方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，不影响原字符串，ie9以上支持 5.6.大小写转换方法 toLowerCase()：转小写 toUpperCase()：转大写 toLocalLowerCase()：特定地区小写 toLocalUpperCase()：特定地区大写 5.7.模式匹配方法5.7.1.math()方法接收一个参数，要么是正则表达式，要么是一个RegExp 5.7.2.search()方法接收一个参数：字符串或RegExp对象指定的一个正则表达式。返回字符串中第一个匹配项的索引 5.7.3.replace()方法接收两个参数：第一个参数可以是一个字符或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替代第一个子字符串。 123var text = "cat,bat,sat";var result = text.replace("at","ond");console.log(result); //"cond,bat,sat" 5.7.4.split()方法基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。（用的比较多） 123var colors = "red,blue,green";var colors1 = colors.split(",");console.log(colors1); //["red","blue","green"] 6.单体内置对象6.1.Global对象所有在全局作用域中定义的属性和函数，都是Global对象。 6.1.1.URI编码方法encodeURI()方法：除了空格之外的其他字符都原封不动，只有空格被替换成了%20。encodeURIcomponent()：替换所有非字母数字字符 6.1.2.eval()方法像一个完整的ECMAScript解析器，接收一个参数，即要执行的JavaScript字符串。 123eval("alert('hi')");//等价于alert("hi"); 在eval()中创建的任何变量或函数都不会被提升 严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误。 6.1.3.Global对象的属性ECMAScript5明确禁止给undefined、NaN和Infinity赋值。 6.2.Math对象6.2.1.min()和max()方法。确定最大最小值。 要找到数组中的最大或最小值，可以使用apply()方法 123var values = [1,2,3,4,5,6,7];var max = Math.max.apply(Math,values);console.log(max); //7 6.2.2.舍入方法 Math.ceil()：向上舍入，将数值向上舍入为最接近的值 Math.floor()：向下舍入，将数值向下舍入为最接近的值 Math.ceil()：标准舍入，即四舍五入 6.2.3.random()方法Math.random()方法返回大于等于0小于0的一个随机数。 可用于随机显示一些名人名言和新闻事件： 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 6.2.4.其他方法像Math.abs(num)、Math.sqrt(num)等等]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、jQuery选择器]]></title>
    <url>%2F2018%2F08%2F19%2F%E4%BA%8C%E3%80%81jQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.基本选择器 选择器 描述 返回 示例 #id 根据给定的的id匹配一个元素 单个元素 $(“#btn”) .class 根据给定的class匹配元素 集合元素 $(“.class”) element 根据给定的元素匹配元素 集合元素 $(“div”) * 匹配所有元素 集合元素 $(“*”) selector1，selector2… 将每个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.demo”) 2.层次选择器 选择器 描述 返回 示例 $(“ancestor descendant”) 选取ancestor元素里的所有decendant（后代）元素 集合元素 $(“parent&gt;child”) 选取parent元素下的child（子）元素 集合元素 $(“prev+next”) 选取紧接在prev元素后的next元素 集合元素 $(“prev~siblings”) 选取prev元素之后的所有sibling（兄弟）元素 集合元素 3.过滤选择器3.1.基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(“div:first”)选取所有div元素中第一个div元素 :last 选取最后一个元素 单个元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(“input:not(.myClass)”)选取class不是myClass的input元素 :even 选取索引是偶数的所有元素，索引从0开始 集合元素 :odd 选取索引是奇数的所有元素，索引从0开始 集合元素 :eq(index) 选取索引等于index的元素（index从0开始） 单个元素 :gt(index) 选取索引大于index的元素（index从0开始） 集合元素 $(“input:gt(1)”)选取索引大于1的input元素（大于1，不包括1） :lt(index) 选取索引小于index的元素（index从0开始） 集合元素 :header 选取所有的标题元素，如h1，h2等 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 3.2.内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(“div:contains(‘我’)”)选取含有文本“我”的div元素 :empty 选取不包含子元素或者文本为空的元素 集合元素 :has(selector) 选组含有选择器所匹配的元素的元素 集合元素 $(“div:has(p)”)选取含有p元素的div元素 :parent 选取含有子元素或者文本的元素 集合元素 3.3.可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 3.4.属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(“div[title=test]”)选取属性title为“test”的div元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 [attribute^=value] 选取属性的值以value的开头的元素 集合元素 [attribute$=value] 选取属性的值以value的结尾的元素 集合元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 [selector1][selector2] 用属性选择器合并成一个符复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(“div[id][title$=’test’]”)选取拥有属性id，并且属性title以“test”结束的div元素 3.5.子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个父元素的第一个子元素 集合元素 $(“ul li:first-child”)选取每个ul中第1个li元素 :last-child 选取每个父元素的最后一个元素 集合元素 :only-child 如果某个元素是它的父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(“ul li:only-child”)在ul中选取是唯一子元素的li元素 3.6.表单对象属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(“#form1 :enabled”)选取id为“form1”的表单内所有可用元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框，复选框） 集合元素 :selected 选取所有被选中的选项元素（下拉列表） 集合元素 4.表单选择器 选择器 描述 返回 示例 :input 选取所有input,textare,select,button元素 集合元素 :text 选取所有的单行文本框 集合元素 :password 选取所有的单行密码框 集合元素 :radio 选取所有的单选框 集合元素 :checkbox 选取所有的复选框 集合元素 :submit 选取所有的提交按钮 集合元素 :image 选取所有的图像按钮 集合元素 :reset 选取所有的重置按钮 集合元素 :button 选取所有的按钮 集合元素 :file 选取所有的上传域 集合元素 :hidden 选取所有不可见元素 集合元素]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、进程的描述与控制]]></title>
    <url>%2F2018%2F08%2F18%2F%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程的描述定义进程：由程序段，相关的数据段和PCB三部分构成 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上的运行的结果，它是系统进行资源分配和调度的一个独立单位 特征 动态性 并发性 独立性 异步性 进程的三种基本状态就绪状态：进程已处于准备好运行的状态，即已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行执行状态：进程已获得CPU，其程序正在执行的状态阻塞状态：正在执行的进程由于发生某事件（I/O请求，申请缓冲区失败等)暂时无法继续执行时的状态 三种状态的转换进程控制块PCB用于描述进程的当前情况以及管理进程运行的全部信息，使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位 具体作用； 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其它进程的同步与通信 进程控制操作系统内核：通常将一些与硬件紧密相关的模块（如中断处理程序等），各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理，进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层面中，将它们常驻内存，即称为OS内核 OS内核两大功能：支撑功能 中断处理 时钟处理 原语操作：一个操作中要么全做，要么全部不做 资源管理功能 进程管理 存储器管理 设备管理 进程同步进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源。临界资源：如打印机，磁带机等临界区：人们把在每个进程中访问临界资源的那段代码称为临界区 同步机制应遵循的规则 空闲让进 忙则等待 有限等待 让权等待 进程通信进程通信的类型 共享存储器系统 管道通信系统 消息传递系统 客户机-服务器系统 消息传递通信的实现方式 直接消息传递系统 信箱通信 线程（Threads）的基本概念线程的引入引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性 程序的并发执行需要经过创建进程，撤销进程和进程切换。在此过程系统付出里较大的时空开销 线程作为调度和分派的基本单位，能使多个程序更好的并发执行，同时又尽量减少系统的开销 线程与进程的比较调度的基本单位传统OS中，进程每次调度时进行的上下文切换，开销较大。引入线程之后，就把线程作为调度和分派的基本单位，是独立运行的基本单位，切换代价远低于进程。 并发性一个进程中的多个线程可以并发执行，使得OS具有更好的并发性，从而能更加有效的提高系统资源的利用率和系统的吞吐率 拥有资源进程可以拥有资源，并作为系统中拥有资源的一个基本单位。线程本身并不拥有系统资源，而是仅有一点能保证独立运行的资源。 独立性在同一个进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 系统开销创建或撤销进程的开销明显大于线程创建或撤销是所付出的开销 支持多处理机系统传统的进程，即单线程进程，只能运行在一个处理机上，而多线程进程，可以将一个进程中的多个线程分配到多个处理机上]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、操作系统引论]]></title>
    <url>%2F2018%2F08%2F14%2F%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[操作系统的基本特性1.并发并行性是指两个或多个事件同一时刻发生。 并发性是指两个或多个事件在同一时间间隔内发生。 操作系统通过引入进程和和线程，使程序能够并发执行。 2.共享资源共享也称资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。 有两种共享方式 互斥共享：临界资源，如打印机，磁带机等。规定一段时间内，只允许一个进程访问该资源。 同时访问：允许一段时间内由多个进程“同时”对它们进行访问。 3.虚拟把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。 主要有两种虚拟技术 时分复用技术：广泛用于实现虚拟处理机、虚拟设备等。利用率高的原因：利用某设备为一用户服务的空闲时间，又转去为其他用户服务 ，使设备得到充分利用。 空分复用技术：利用存储器的空闲时间分区域存放和运行其他的多道程序，以此来提高内存利用率。 4.异步每个进程的速度，时间等等是不可预知的。即进程是以人们不可预知的速度推进的，此即进程的异步性。 操作系统的主要功能1.处理机管理功能进程控制、进程同步、进程通信、调度。 2.存储器管理功能内存分配、内存保护、地址映射、内存扩充 3.设备管理功能缓冲管理、设备分配、设备处理 4.文件管理功能文件存储空间的管理、目录管理、文件的读/写管理和保护 微内核OS结构什么是微内核 足够小的内核 基于客户/服务器模式 应用“机制与策略分离”原理 采用面向对象技术 基本功能 进程（线程）管理 低级存储器管理 中断和陷入处理 优缺点优点： 提高系统的可扩展性 增强了系统的可靠性 可移植性强 提供了对分布式系统的支持 融入了面向对象技术 缺点 操作系统的运行效率降低（需要多次上下文的切换）]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域，了解一下]]></title>
    <url>%2F2018%2F08%2F09%2F%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[为什么要跨域同源策略同源策略是浏览器的一种安全策略，是为了保证用户信息的安全，防止恶意的网站窃取数据。所谓同源是指域名，协议，端口完全相同。 同源或者不同源说的是两个地址之间的关系，不同源之间请求我们称之为跨域请求。 如果非同源，有三种行为会受到限制： Cookie、LocalStorage和IndexDB无法读取 DOM 无法获得。 AJAX 请求不能发送。 这里主要讲AJAX如何在不同源之间发送请求。 解决跨域JSONP原理：在客户端借助script标签请求服务端的一个动态网页服务端的这个动态网页返回一段带有函数调用的JavaScript全局函数调用的脚本，将原本需要返回给客户端的数据传递进去 封装一个jsonp：123456789101112131415161718192021222324252627function jsonp(url, data, callback) &#123; //保证回调不会重名 var callbackName = 'jsonp_' + Date.now() + Math.random().toString().substr(2.7); //处理以对象形式传过来的参数 if (typeof data === 'object') &#123; var funArr = []; for (var key in data) &#123; var value = data[key]; funArr.push(key + '=' + value); &#125; data = funArr.join('&amp;'); &#125; //主要 var script = document.createElement('script'); script.src = url + '?' + data + 'callback=' + callbackName; document.body.appendChild(script); window[callbackName] = function (data) &#123; callback(data); //结束后删除标签 delete window[callbackName]; document.body.removeChild(script); &#125;&#125; 存在的问题： JSONP需要服务端配合，服务端按照客户端的要求返回一段JavaScript调用客户端的函数 只能发送GET请求 如果在jQuery中使用JSONP，就是将dataType设置为jsonp]]></content>
  </entry>
  <entry>
    <title><![CDATA[一、认识jQuery]]></title>
    <url>%2F2018%2F08%2F08%2F%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86jQuery%2F</url>
    <content type="text"><![CDATA[1.window.onload与$(document).ready()的对比 window.onload $(document).ready() 执行时机 必须等待网页中所有的内容加载完毕后（包括图片）才能执行 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完 编写个数 不能同时编写多个，编写多个只会执行最后一个 能同时编写多个，每个都会执行 简化写法 无 $(document).ready(function(){});可简写为$(function(){}) 2.jQuery对象在jQuery对象中无法使用DOM对象的任何方法，同样DOM对象也不能使用jQuery里的方法 3.jQuery对象和DOM对象的相互转换3.1.jQuery对象转成DOM对象(1) jQuery对象是一个数组对象，可以通过[index]的方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn[0]; //DOM对象 (2) 另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn.get(0); //DOM对象 3.2DOM对象转成jQuery对象12var btn = document.getElementById('btn'); //DOM对象var $btn = $(btn); //jQuery对象 4.解决jQuery和其他库的冲突4.1jQuery库在其他库之后导入在其他库和jQuery库都被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权移交给其他js库 1jQuery.noConflict(); //将变量$的控制权移交给其他js库 还可以自定义一个快捷方式 1234var $j = jQuery.noConflict(); //自定义一个快捷方式$j(function()&#123; //...&#125;) 此外还有以下两种解决方法 1234567一：jQuery.noConflict(); //将变量$的控制权移交给其他js库jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $('#btn').on('click',function()&#123; //... &#125;)&#125;) 1234567二：jQuery.noConflict(); //将变量$的控制权移交给其他js库(function($)&#123; //定义匿名函数并设置形参为$ $('#btn').on('click',function()&#123; //... &#125;)&#125;)(jQuery) //执行匿名函数且传递实参jQuery 4.2.jQuery库在其他库之前导入如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作。同时，可以使用$()方法作为其他库的快捷方式。无需调用jQuery.noConflict()函数。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise初体验]]></title>
    <url>%2F2018%2F06%2F13%2FPromise%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 想了解更多有关回调的，可以去看这篇文章Callback Hell ​ 想了解更多有关Promise的使用，推荐去阮一峰老师的ES6教程阮一峰Promise ​ 因最近在学nodejs，所以文章结合node进行说明 回调函数解决异步编程先简单了解一下回调函数解决异步操作所引起的回调地狱问题。 我们知道异步编程无法保证代码的顺序性，如 1234567891011121314151617181920var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa)&#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) &#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc)&#125;) 在这里我们不能保证按顺序输出aaa，bbb，ccc。 我们可以使用传统的回调函数嵌套的方法 来解决这样的问题： 12345678910111213141516171819var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc) &#125;) &#125;) 很显然，当嵌套过多时，既会产生人们常说的回调地狱问题。所以就有了Promise Promise是什么Promise是ES6的语法，是异步编程的一种解决方案，传统的解决异步编程方法是使用回调函数来解决，但如果需要多个回调就会有回调地狱的问题，而用Promise则会更加合理 简单来说，Promise是一个容器，里面保存着异步操作的结果,它有三种状态：pending（进行中），resolved（已成功），rejected（以失败），一旦状态改变，就不会再变回来，即从pending变为resolved和从pending变为rejected两种可能，当这两种可能已经发生，状态就不会再变了。以下的内容均结合node的异步操作来说明 简单使用Promise是一个构造函数，首先要创造一个Promise实例。 12345678910111213var promiseOne = new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; //容器中的任务失败了，把容器中的pending状态变为rejected reject(err) //调用reject就相当于调用了then方法的第二个参数函数 &#125; else &#123; //容器中的任务成功了， 把容器中的pending状态变为resolved resolve(data) //也就是说这里调用的resolve方法实际就是then方法传递的那个function &#125; &#125;)&#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 1234567promiseOne.then(function (data) &#123; //成功 console.log(data)&#125;, function (err) &#123; //失败 console.log(err)&#125;) then方法接收两个回调函数，第一个回调函数即调用上文中的resolve（data），第二个回调函数可选，即调用上文中的rejecte（err） 简单封装Promise版本的readFile方法1234567891011121314151617181920212223242526var fs = require('fs')function promiseReadFile(filePath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;promiseReadFile(filePath) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) &#125;)]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>-ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose简单操作]]></title>
    <url>%2F2018%2F06%2F10%2FMongoose%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装1npm install mongoose 快速上手1.引入mongoose模块1var mongoose = require('mongoose'); 2.定义一个Schema：一种以文件形式存储的数据库模型骨架1var Schema = mongoose.Schema 3.连接数据库,指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来(myserver是自己创建的)1mongoose.connect('mongodb://localhost/myserver') 4.设计文档结构，官方文档的123456789101112var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 这里我用这样的来做简单例子12345678910111213var userSchema = new Schema(&#123; username:&#123; type: String, require: true &#125;, password:&#123; type: String, require: true &#125;, email:&#123; type:String &#125;&#125;) 5.将Shcema发布为model mongoose.model 方法就是用来将Shcema发布为 model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称例如这里的 User 最终会变为 users 集合名称 第二个参数：架构 Schema 返回值：模型构造函数1var User = mongoose.model('User',userSchema) 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行增删改查了 增加数据1234567891011121314var admin = new User(&#123; username:'张三', password:'12345', email:'email@email.com'&#125;)admin.save(function(err,ret)&#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功'); console.log(ret) &#125;&#125;) 查询数据查询所有123456789User.find(function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 按条件查询所有1234567891011User.find(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 查询一个1234567891011User.findOne(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 删除数据按条件删除所有1234567891011User.remove(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功'); console.log(ret) &#125;&#125;) 按条件删除一个:与上面相似1Model.findOneAndRemove(condition,[option],[callback]) 根据id删除一个1Model.findByIdAndRemove(id,[option],[callback]) 更新数据根据id更新一个1234567891011User.findByIdAndUpdate('xxxxxx',&#123; username:'李四'&#125;,function(err,ret)&#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功'); console.log(ret) &#125;&#125;) 根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个1Model.findOneAndUpdate(conditions,update,[options],[callback])]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
