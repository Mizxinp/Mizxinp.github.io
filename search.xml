<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、jQuery选择器]]></title>
    <url>%2F2018%2F08%2F19%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.基本选择器 选择器 描述 返回 示例 #id 根据给定的的id匹配一个元素 单个元素 $(“#btn”) .class 根据给定的class匹配元素 集合元素 $(“.class”) element 根据给定的元素匹配元素 集合元素 $(“div”) * 匹配所有元素 集合元素 $(“*”) selector1，selector2… 将每个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.demo”) 2.层次选择器 选择器 描述 返回 示例 $(“ancestor descendant”) 选取ancestor元素里的所有decendant（后代）元素 集合元素 $(“parent&gt;child”) 选取parent元素下的child（子）元素 集合元素 $(“prev+next”) 选取紧接在prev元素后的next元素 集合元素 $(“prev~siblings”) 选取prev元素之后的所有sibling（兄弟）元素 集合元素 3.过滤选择器3.1.基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(“div:first”)选取所有div元素中第一个div元素 :last 选取最后一个元素 单个元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(“input:not(.myClass)”)选取class不是myClass的input元素 :even 选取索引是偶数的所有元素，索引从0开始 集合元素 :odd 选取索引是奇数的所有元素，索引从0开始 集合元素 :eq(index) 选取索引等于index的元素（index从0开始） 单个元素 :gt(index) 选取索引大于index的元素（index从0开始） 集合元素 $(“input:gt(1)”)选取索引大于1的input元素（大于1，不包括1） :lt(index) 选取索引小于index的元素（index从0开始） 集合元素 :header 选取所有的标题元素，如h1，h2等 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 3.2.内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(“div:contains(‘我’)”)选取含有文本“我”的div元素 :empty 选取不包含子元素或者文本为空的元素 集合元素 :has(selector) 选组含有选择器所匹配的元素的元素 集合元素 $(“div:has(p)”)选取含有p元素的div元素 :parent 选取含有子元素或者文本的元素 集合元素 3.3.可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 3.4.属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(“div[title=test]”)选取属性title为“test”的div元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 [attribute^=value] 选取属性的值以value的开头的元素 集合元素 [attribute$=value] 选取属性的值以value的结尾的元素 集合元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 [selector1][selector2] 用属性选择器合并成一个符复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(“div[id][title$=’test’]”)选取拥有属性id，并且属性title以“test”结束的div元素 3.5.子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个父元素的第一个子元素 集合元素 $(“ul li:first-child”)选取每个ul中第1个li元素 :last-child 选取每个父元素的最后一个元素 集合元素 :only-child 如果某个元素是它的父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(“ul li:only-child”)在ul中选取是唯一子元素的li元素 3.6.表单对象属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(“#form1 :enabled”)选取id为“form1”的表单内所有可用元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框，复选框） 集合元素 :selected 选取所有被选中的选项元素（下拉列表） 集合元素 4.表单选择器 选择器 描述 返回 示例 :input 选取所有input,textare,select,button元素 集合元素 :text 选取所有的单行文本框 集合元素 :password 选取所有的单行密码框 集合元素 :radio 选取所有的单选框 集合元素 :checkbox 选取所有的复选框 集合元素 :submit 选取所有的提交按钮 集合元素 :image 选取所有的图像按钮 集合元素 :reset 选取所有的重置按钮 集合元素 :button 选取所有的按钮 集合元素 :file 选取所有的上传域 集合元素 :hidden 选取所有不可见元素 集合元素]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、进程的描述与控制]]></title>
    <url>%2F2018%2F08%2F18%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程的描述定义进程：由程序段，相关的数据段和PCB三部分构成 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上的运行的结果，它是系统进行资源分配和调度的一个独立单位 特征 动态性 并发性 独立性 异步性 进程的三种基本状态就绪状态：进程已处于准备好运行的状态，即已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行执行状态：进程已获得CPU，其程序正在执行的状态阻塞状态：正在执行的进程由于发生某事件（I/O请求，申请缓冲区失败等)暂时无法继续执行时的状态 三种状态的转换进程控制块PCB用于描述进程的当前情况以及管理进程运行的全部信息，使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位 具体作用； 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其它进程的同步与通信 进程控制操作系统内核：通常将一些与硬件紧密相关的模块（如中断处理程序等），各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理，进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层面中，将它们常驻内存，即称为OS内核 OS内核两大功能：支撑功能 中断处理 时钟处理 原语操作：一个操作中要么全做，要么全部不做 资源管理功能 进程管理 存储器管理 设备管理 进程同步进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源。临界资源：如打印机，磁带机等临界区：人们把在每个进程中访问临界资源的那段代码称为临界区 同步机制应遵循的规则 空闲让进 忙则等待 有限等待 让权等待 进程通信进程通信的类型 共享存储器系统 管道通信系统 消息传递系统 客户机-服务器系统 消息传递通信的实现方式 直接消息传递系统 信箱通信 线程（Threads）的基本概念线程的引入引入线程是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性 程序的并发执行需要经过创建进程，撤销进程和进程切换。在此过程系统付出里较大的时空开销 线程作为调度和分派的基本单位，能使多个程序更好的并发执行，同时又尽量减少系统的开销 线程与进程的比较调度的基本单位传统OS中，进程每次调度时进行的上下文切换，开销较大。引入线程之后，就把线程作为调度和分派的基本单位，是独立运行的基本单位，切换代价远低于进程。 并发性一个进程中的多个线程可以并发执行，使得OS具有更好的并发性，从而能更加有效的提高系统资源的利用率和系统的吞吐率 拥有资源进程可以拥有资源，并作为系统中拥有资源的一个基本单位。线程本身并不拥有系统资源，而是仅有一点能保证独立运行的资源。 独立性在同一个进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 系统开销创建或撤销进程的开销明显大于线程创建或撤销是所付出的开销 支持多处理机系统传统的进程，即单线程进程，只能运行在一个处理机上，而多线程进程，可以将一个进程中的多个线程分配到多个处理机上]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、操作系统引论]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[操作系统的基本特性1.并发并行性是指两个或多个事件同一时刻发生。 并发性是指两个或多个事件在同一时间间隔内发生。 操作系统通过引入进程和和线程，使程序能够并发执行。 2.共享资源共享也称资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。 有两种共享方式 互斥共享：临界资源，如打印机，磁带机等。规定一段时间内，只允许一个进程访问该资源。 同时访问：允许一段时间内由多个进程“同时”对它们进行访问。 3.虚拟把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。 主要有两种虚拟技术 时分复用技术：广泛用于实现虚拟处理机、虚拟设备等。利用率高的原因：利用某设备为一用户服务的空闲时间，又转去为其他用户服务 ，使设备得到充分利用。 空分复用技术：利用存储器的空闲时间分区域存放和运行其他的多道程序，以此来提高内存利用率。 4.异步每个进程的速度，时间等等是不可预知的。即进程是以人们不可预知的速度推进的，此即进程的异步性。 操作系统的主要功能1.处理机管理功能进程控制、进程同步、进程通信、调度。 2.存储器管理功能内存分配、内存保护、地址映射、内存扩充 3.设备管理功能缓冲管理、设备分配、设备处理 4.文件管理功能文件存储空间的管理、目录管理、文件的读/写管理和保护 微内核OS结构什么是微内核 足够小的内核 基于客户/服务器模式 应用“机制与策略分离”原理 采用面向对象技术 基本功能 进程（线程）管理 低级存储器管理 中断和陷入处理 优缺点优点： 提高系统的可扩展性 增强了系统的可靠性 可移植性强 提供了对分布式系统的支持 融入了面向对象技术 缺点 操作系统的运行效率降低（需要多次上下文的切换）]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域，了解一下]]></title>
    <url>%2F2018%2F08%2F09%2F%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[为什么要跨域同源策略同源策略是浏览器的一种安全策略，是为了保证用户信息的安全，防止恶意的网站窃取数据。所谓同源是指域名，协议，端口完全相同。 同源或者不同源说的是两个地址之间的关系，不同源之间请求我们称之为跨域请求。 如果非同源，有三种行为会受到限制： Cookie、LocalStorage和IndexDB无法读取 DOM 无法获得。 AJAX 请求不能发送。 这里主要讲AJAX如何在不同源之间发送请求。 解决跨域JSONP原理：在客户端借助script标签请求服务端的一个动态网页服务端的这个动态网页返回一段带有函数调用的JavaScript全局函数调用的脚本，将原本需要返回给客户端的数据传递进去 封装一个jsonp：123456789101112131415161718192021222324252627function jsonp(url, data, callback) &#123; //保证回调不会重名 var callbackName = 'jsonp_' + Date.now() + Math.random().toString().substr(2.7); //处理以对象形式传过来的参数 if (typeof data === 'object') &#123; var funArr = []; for (var key in data) &#123; var value = data[key]; funArr.push(key + '=' + value); &#125; data = funArr.join('&amp;'); &#125; //主要 var script = document.createElement('script'); script.src = url + '?' + data + 'callback=' + callbackName; document.body.appendChild(script); window[callbackName] = function (data) &#123; callback(data); //结束后删除标签 delete window[callbackName]; document.body.removeChild(script); &#125;&#125; 存在的问题： JSONP需要服务端配合，服务端按照客户端的要求返回一段JavaScript调用客户端的函数 只能发送GET请求 如果在jQuery中使用JSONP，就是将dataType设置为jsonp]]></content>
  </entry>
  <entry>
    <title><![CDATA[一、认识jQuery]]></title>
    <url>%2F2018%2F08%2F08%2F%E8%AE%A4%E8%AF%86jQuery%2F</url>
    <content type="text"><![CDATA[1.window.onload与$(document).ready()的对比 window.onload $(document).ready() 执行时机 必须等待网页中所有的内容加载完毕后（包括图片）才能执行 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完 编写个数 不能同时编写多个，编写多个只会执行最后一个 能同时编写多个，每个都会执行 简化写法 无 $(document).ready(function(){});可简写为$(function(){}) 2.jQuery对象在jQuery对象中无法使用DOM对象的任何方法，同样DOM对象也不能使用jQuery里的方法 3.jQuery对象和DOM对象的相互转换3.1.jQuery对象转成DOM对象(1) jQuery对象是一个数组对象，可以通过[index]的方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn[0]; //DOM对象 (2) 另一种方法是jQuery本身提供的，通过get(index)方法得到相应的DOM对象 12var $btn = $('btn'); //jQuery对象var btn = $btn.get(0); //DOM对象 3.2DOM对象转成jQuery对象12var btn = document.getElementById('btn'); //DOM对象var $btn = $(btn); //jQuery对象 4.解决jQuery和其他库的冲突4.1jQuery库在其他库之后导入在其他库和jQuery库都被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权移交给其他js库 1jQuery.noConflict(); //将变量$的控制权移交给其他js库 还可以自定义一个快捷方式 1234var $j = jQuery.noConflict(); //自定义一个快捷方式$j(function()&#123; //...&#125;) 此外还有以下两种解决方法 1234567一：jQuery.noConflict(); //将变量$的控制权移交给其他js库jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $('#btn').on('click',function()&#123; //... &#125;)&#125;) 1234567二：jQuery.noConflict(); //将变量$的控制权移交给其他js库(function($)&#123; //定义匿名函数并设置形参为$ $('#btn').on('click',function()&#123; //... &#125;)&#125;)(jQuery) //执行匿名函数且传递实参jQuery 4.2.jQuery库在其他库之前导入如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作。同时，可以使用$()方法作为其他库的快捷方式。无需调用jQuery.noConflict()函数。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise初体验]]></title>
    <url>%2F2018%2F06%2F13%2FPromise%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 想了解更多有关回调的，可以去看这篇文章Callback Hell ​ 想了解更多有关Promise的使用，推荐去阮一峰老师的ES6教程阮一峰Promise ​ 因最近在学nodejs，所以文章结合node进行说明 回调函数解决异步编程先简单了解一下回调函数解决异步操作所引起的回调地狱问题。 我们知道异步编程无法保证代码的顺序性，如 1234567891011121314151617181920var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa)&#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) &#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc)&#125;) 在这里我们不能保证按顺序输出aaa，bbb，ccc。 我们可以使用传统的回调函数嵌套的方法 来解决这样的问题： 12345678910111213141516171819var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc) &#125;) &#125;) 很显然，当嵌套过多时，既会产生人们常说的回调地狱问题。所以就有了Promise Promise是什么Promise是ES6的语法，是异步编程的一种解决方案，传统的解决异步编程方法是使用回调函数来解决，但如果需要多个回调就会有回调地狱的问题，而用Promise则会更加合理 简单来说，Promise是一个容器，里面保存着异步操作的结果,它有三种状态：pending（进行中），resolved（已成功），rejected（以失败），一旦状态改变，就不会再变回来，即从pending变为resolved和从pending变为rejected两种可能，当这两种可能已经发生，状态就不会再变了。以下的内容均结合node的异步操作来说明 简单使用Promise是一个构造函数，首先要创造一个Promise实例。 12345678910111213var promiseOne = new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; //容器中的任务失败了，把容器中的pending状态变为rejected reject(err) //调用reject就相当于调用了then方法的第二个参数函数 &#125; else &#123; //容器中的任务成功了， 把容器中的pending状态变为resolved resolve(data) //也就是说这里调用的resolve方法实际就是then方法传递的那个function &#125; &#125;)&#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 1234567promiseOne.then(function (data) &#123; //成功 console.log(data)&#125;, function (err) &#123; //失败 console.log(err)&#125;) then方法接收两个回调函数，第一个回调函数即调用上文中的resolve（data），第二个回调函数可选，即调用上文中的rejecte（err） 简单封装Promise版本的readFile方法1234567891011121314151617181920212223242526var fs = require('fs')function promiseReadFile(filePath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;promiseReadFile(filePath) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) &#125;)]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>-ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose简单操作]]></title>
    <url>%2F2018%2F06%2F10%2FMongoose%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装1npm install mongoose 快速上手1.引入mongoose模块1var mongoose = require('mongoose'); 2.定义一个Schema：一种以文件形式存储的数据库模型骨架1var Schema = mongoose.Schema 3.连接数据库,指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来(myserver是自己创建的)1mongoose.connect('mongodb://localhost/myserver') 4.设计文档结构，官方文档的123456789101112var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 这里我用这样的来做简单例子12345678910111213var userSchema = new Schema(&#123; username:&#123; type: String, require: true &#125;, password:&#123; type: String, require: true &#125;, email:&#123; type:String &#125;&#125;) 5.将Shcema发布为model mongoose.model 方法就是用来将Shcema发布为 model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称例如这里的 User 最终会变为 users 集合名称 第二个参数：架构 Schema 返回值：模型构造函数1var User = mongoose.model('User',userSchema) 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行增删改查了 增加数据1234567891011121314var admin = new User(&#123; username:'张三', password:'12345', email:'email@email.com'&#125;)admin.save(function(err,ret)&#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功'); console.log(ret) &#125;&#125;) 查询数据查询所有123456789User.find(function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 按条件查询所有1234567891011User.find(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 查询一个1234567891011User.findOne(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 删除数据按条件删除所有1234567891011User.remove(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功'); console.log(ret) &#125;&#125;) 按条件删除一个:与上面相似1Model.findOneAndRemove(condition,[option],[callback]) 根据id删除一个1Model.findByIdAndRemove(id,[option],[callback]) 更新数据根据id更新一个1234567891011User.findByIdAndUpdate('xxxxxx',&#123; username:'李四'&#125;,function(err,ret)&#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功'); console.log(ret) &#125;&#125;) 根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个1Model.findOneAndUpdate(conditions,update,[options],[callback])]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
