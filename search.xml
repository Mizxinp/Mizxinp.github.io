<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise初体验]]></title>
    <url>%2F2018%2F06%2F13%2FPromise%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 想了解更多有关回调的，可以去看这篇文章Callback Hell ​ 想了解更多有关Promise的使用，推荐去阮一峰老师的ES6教程阮一峰Promise ​ 因最近在学nodejs，所以文章结合node进行说明 回调函数解决异步编程先简单了解一下回调函数解决异步操作所引起的回调地狱问题。 我们知道异步编程无法保证代码的顺序性，如 1234567891011121314151617181920var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa)&#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) &#125;)fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc)&#125;) 在这里我们不能保证按顺序输出aaa，bbb，ccc。 我们可以使用传统的回调函数嵌套的方法 来解决这样的问题： 12345678910111213141516171819var fs = require('fs')fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(aaa) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(bbb) fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; throw err &#125; console.log(ccc) &#125;) &#125;) 很显然，当嵌套过多时，既会产生人们常说的回调地狱问题。所以就有了Promise Promise是什么Promise是ES6的语法，是异步编程的一种解决方案，传统的解决异步编程方法是使用回调函数来解决，但如果需要多个回调就会有回调地狱的问题，而用Promise则会更加合理 简单来说，Promise是一个容器，里面保存着异步操作的结果,它有三种状态：pending（进行中），resolved（已成功），rejected（以失败），一旦状态改变，就不会再变回来，即从pending变为resolved和从pending变为rejected两种可能，当这两种可能已经发生，状态就不会再变了。以下的内容均结合node的异步操作来说明 简单使用Promise是一个构造函数，首先要创造一个Promise实例。 12345678910111213var promiseOne = new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; //容器中的任务失败了，把容器中的pending状态变为rejected reject(err) //调用reject就相当于调用了then方法的第二个参数函数 &#125; else &#123; //容器中的任务成功了， 把容器中的pending状态变为resolved resolve(data) //也就是说这里调用的resolve方法实际就是then方法传递的那个function &#125; &#125;)&#125;) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 1234567promiseOne.then(function (data) &#123; //成功 console.log(data)&#125;, function (err) &#123; //失败 console.log(err)&#125;) then方法接收两个回调函数，第一个回调函数即调用上文中的resolve（data），第二个回调函数可选，即调用上文中的rejecte（err） 简单封装Promise版本的readFile方法1234567891011121314151617181920212223242526var fs = require('fs')function promiseReadFile(filePath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filePath, 'utf8', function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;promiseReadFile(filePath) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) return promiseReadFile(filePath) &#125;) .then(function (data) &#123; console.log(data) &#125;)]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>-ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose简单操作]]></title>
    <url>%2F2018%2F06%2F10%2FMongoose%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装1npm install mongoose 快速上手1.引入mongoose模块1var mongoose = require('mongoose'); 2.定义一个Schema：一种以文件形式存储的数据库模型骨架1var Schema = mongoose.Schema 3.连接数据库,指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来(myserver是自己创建的)1mongoose.connect('mongodb://localhost/myserver') 4.设计文档结构，官方文档的123456789101112var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 这里我用这样的来做简单例子12345678910111213var userSchema = new Schema(&#123; username:&#123; type: String, require: true &#125;, password:&#123; type: String, require: true &#125;, email:&#123; type:String &#125;&#125;) 5.将Shcema发布为model mongoose.model 方法就是用来将Shcema发布为 model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称例如这里的 User 最终会变为 users 集合名称 第二个参数：架构 Schema 返回值：模型构造函数1var User = mongoose.model('User',userSchema) 当有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行增删改查了 增加数据1234567891011121314var admin = new User(&#123; username:'张三', password:'12345', email:'email@email.com'&#125;)admin.save(function(err,ret)&#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功'); console.log(ret) &#125;&#125;) 查询数据查询所有123456789User.find(function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 按条件查询所有1234567891011User.find(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 查询一个1234567891011User.findOne(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log('查询成功'); console.log(ret) &#125;&#125;) 删除数据按条件删除所有1234567891011User.remove(&#123; username:'张三'&#125;,function(err,ret)&#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功'); console.log(ret) &#125;&#125;) 按条件删除一个:与上面相似1Model.findOneAndRemove(condition,[option],[callback]) 根据id删除一个1Model.findByIdAndRemove(id,[option],[callback]) 更新数据根据id更新一个1234567891011User.findByIdAndUpdate('xxxxxx',&#123; username:'李四'&#125;,function(err,ret)&#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功'); console.log(ret) &#125;&#125;) 根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据指定条件更新一个1Model.findOneAndUpdate(conditions,update,[options],[callback])]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
